using System;

// namespace Storage.Imapi
namespace Win32
{
	extension Win32
	{
		// --- Constants ---
		
		public const uint32 IMAPI_SECTOR_SIZE = 2048;
		public const uint32 IMAPI2_DEFAULT_COMMAND_TIMEOUT = 10;
		public const uint32 DISPID_DDISCMASTER2EVENTS_DEVICEADDED = 256;
		public const uint32 DISPID_DDISCMASTER2EVENTS_DEVICEREMOVED = 257;
		public const uint32 DISPID_IDISCRECORDER2_EJECTMEDIA = 256;
		public const uint32 DISPID_IDISCRECORDER2_CLOSETRAY = 257;
		public const uint32 DISPID_IDISCRECORDER2_ACQUIREEXCLUSIVEACCESS = 258;
		public const uint32 DISPID_IDISCRECORDER2_RELEASEEXCLUSIVEACCESS = 259;
		public const uint32 DISPID_IDISCRECORDER2_DISABLEMCN = 260;
		public const uint32 DISPID_IDISCRECORDER2_ENABLEMCN = 261;
		public const uint32 DISPID_IDISCRECORDER2_INITIALIZEDISCRECORDER = 262;
		public const uint32 DISPID_IDISCRECORDER2_ACTIVEDISCRECORDER = 0;
		public const uint32 DISPID_IDISCRECORDER2_VENDORID = 513;
		public const uint32 DISPID_IDISCRECORDER2_PRODUCTID = 514;
		public const uint32 DISPID_IDISCRECORDER2_PRODUCTREVISION = 515;
		public const uint32 DISPID_IDISCRECORDER2_VOLUMENAME = 516;
		public const uint32 DISPID_IDISCRECORDER2_VOLUMEPATHNAMES = 517;
		public const uint32 DISPID_IDISCRECORDER2_DEVICECANLOADMEDIA = 518;
		public const uint32 DISPID_IDISCRECORDER2_LEGACYDEVICENUMBER = 519;
		public const uint32 DISPID_IDISCRECORDER2_SUPPORTEDFEATUREPAGES = 520;
		public const uint32 DISPID_IDISCRECORDER2_CURRENTFEATUREPAGES = 521;
		public const uint32 DISPID_IDISCRECORDER2_SUPPORTEDPROFILES = 522;
		public const uint32 DISPID_IDISCRECORDER2_CURRENTPROFILES = 523;
		public const uint32 DISPID_IDISCRECORDER2_SUPPORTEDMODEPAGES = 524;
		public const uint32 DISPID_IDISCRECORDER2_EXCLUSIVEACCESSOWNER = 525;
		public const uint32 DISPID_IWRITEENGINE2_WRITESECTION = 512;
		public const uint32 DISPID_IWRITEENGINE2_CANCELWRITE = 513;
		public const uint32 DISPID_IWRITEENGINE2_DISCRECORDER = 256;
		public const uint32 DISPID_IWRITEENGINE2_USESTREAMINGWRITE12 = 257;
		public const uint32 DISPID_IWRITEENGINE2_STARTINGSECTORSPERSECOND = 258;
		public const uint32 DISPID_IWRITEENGINE2_ENDINGSECTORSPERSECOND = 259;
		public const uint32 DISPID_IWRITEENGINE2_BYTESPERSECTOR = 260;
		public const uint32 DISPID_IWRITEENGINE2_WRITEINPROGRESS = 261;
		public const uint32 DISPID_IWRITEENGINE2EVENTARGS_STARTLBA = 256;
		public const uint32 DISPID_IWRITEENGINE2EVENTARGS_SECTORCOUNT = 257;
		public const uint32 DISPID_IWRITEENGINE2EVENTARGS_LASTREADLBA = 258;
		public const uint32 DISPID_IWRITEENGINE2EVENTARGS_LASTWRITTENLBA = 259;
		public const uint32 DISPID_IWRITEENGINE2EVENTARGS_TOTALDEVICEBUFFER = 260;
		public const uint32 DISPID_IWRITEENGINE2EVENTARGS_USEDDEVICEBUFFER = 261;
		public const uint32 DISPID_IWRITEENGINE2EVENTARGS_TOTALSYSTEMBUFFER = 262;
		public const uint32 DISPID_IWRITEENGINE2EVENTARGS_USEDSYSTEMBUFFER = 263;
		public const uint32 DISPID_IWRITEENGINE2EVENTARGS_FREESYSTEMBUFFER = 264;
		public const uint32 DISPID_DWRITEENGINE2EVENTS_UPDATE = 256;
		public const uint32 DISPID_IDISCFORMAT2_RECORDERSUPPORTED = 2048;
		public const uint32 DISPID_IDISCFORMAT2_MEDIASUPPORTED = 2049;
		public const uint32 DISPID_IDISCFORMAT2_MEDIAPHYSICALLYBLANK = 1792;
		public const uint32 DISPID_IDISCFORMAT2_MEDIAHEURISTICALLYBLANK = 1793;
		public const uint32 DISPID_IDISCFORMAT2_SUPPORTEDMEDIATYPES = 1794;
		public const uint32 DISPID_IDISCFORMAT2ERASE_RECORDER = 256;
		public const uint32 DISPID_IDISCFORMAT2ERASE_FULLERASE = 257;
		public const uint32 DISPID_IDISCFORMAT2ERASE_MEDIATYPE = 258;
		public const uint32 DISPID_IDISCFORMAT2ERASE_CLIENTNAME = 259;
		public const uint32 DISPID_IDISCFORMAT2ERASE_ERASEMEDIA = 513;
		public const uint32 DISPID_IDISCFORMAT2ERASEEVENTS_UPDATE = 512;
		public const uint32 DISPID_IDISCFORMAT2DATA_RECORDER = 256;
		public const uint32 DISPID_IDISCFORMAT2DATA_BUFFERUNDERRUNFREEDISABLED = 257;
		public const uint32 DISPID_IDISCFORMAT2DATA_POSTGAPALREADYINIMAGE = 260;
		public const uint32 DISPID_IDISCFORMAT2DATA_CURRENTMEDIASTATUS = 262;
		public const uint32 DISPID_IDISCFORMAT2DATA_WRITEPROTECTSTATUS = 263;
		public const uint32 DISPID_IDISCFORMAT2DATA_TOTALSECTORS = 264;
		public const uint32 DISPID_IDISCFORMAT2DATA_FREESECTORS = 265;
		public const uint32 DISPID_IDISCFORMAT2DATA_NEXTWRITABLEADDRESS = 266;
		public const uint32 DISPID_IDISCFORMAT2DATA_STARTSECTOROFPREVIOUSSESSION = 267;
		public const uint32 DISPID_IDISCFORMAT2DATA_LASTSECTOROFPREVIOUSSESSION = 268;
		public const uint32 DISPID_IDISCFORMAT2DATA_FORCEMEDIATOBECLOSED = 269;
		public const uint32 DISPID_IDISCFORMAT2DATA_DISABLEDVDCOMPATIBILITYMODE = 270;
		public const uint32 DISPID_IDISCFORMAT2DATA_CURRENTMEDIATYPE = 271;
		public const uint32 DISPID_IDISCFORMAT2DATA_CLIENTNAME = 272;
		public const uint32 DISPID_IDISCFORMAT2DATA_REQUESTEDWRITESPEED = 273;
		public const uint32 DISPID_IDISCFORMAT2DATA_REQUESTEDROTATIONTYPEISPURECAV = 274;
		public const uint32 DISPID_IDISCFORMAT2DATA_CURRENTWRITESPEED = 275;
		public const uint32 DISPID_IDISCFORMAT2DATA_CURRENTROTATIONTYPEISPURECAV = 276;
		public const uint32 DISPID_IDISCFORMAT2DATA_SUPPORTEDWRITESPEEDS = 277;
		public const uint32 DISPID_IDISCFORMAT2DATA_SUPPORTEDWRITESPEEDDESCRIPTORS = 278;
		public const uint32 DISPID_IDISCFORMAT2DATA_FORCEOVERWRITE = 279;
		public const uint32 DISPID_IDISCFORMAT2DATA_MUTLISESSIONINTERFACES = 280;
		public const uint32 DISPID_IDISCFORMAT2DATA_WRITE = 512;
		public const uint32 DISPID_IDISCFORMAT2DATA_CANCELWRITE = 513;
		public const uint32 DISPID_IDISCFORMAT2DATA_SETWRITESPEED = 514;
		public const uint32 DISPID_DDISCFORMAT2DATAEVENTS_UPDATE = 512;
		public const uint32 DISPID_IDISCFORMAT2DATAEVENTARGS_ELAPSEDTIME = 768;
		public const uint32 DISPID_IDISCFORMAT2DATAEVENTARGS_ESTIMATEDREMAININGTIME = 769;
		public const uint32 DISPID_IDISCFORMAT2DATAEVENTARGS_ESTIMATEDTOTALTIME = 770;
		public const uint32 DISPID_IDISCFORMAT2DATAEVENTARGS_CURRENTACTION = 771;
		public const uint32 DISPID_IDISCFORMAT2TAO_RECORDER = 256;
		public const uint32 DISPID_IDISCFORMAT2TAO_BUFFERUNDERRUNFREEDISABLED = 258;
		public const uint32 DISPID_IDISCFORMAT2TAO_NUMBEROFEXISTINGTRACKS = 259;
		public const uint32 DISPID_IDISCFORMAT2TAO_TOTALSECTORSONMEDIA = 260;
		public const uint32 DISPID_IDISCFORMAT2TAO_FREESECTORSONMEDIA = 261;
		public const uint32 DISPID_IDISCFORMAT2TAO_USEDSECTORSONMEDIA = 262;
		public const uint32 DISPID_IDISCFORMAT2TAO_DONOTFINALIZEMEDIA = 263;
		public const uint32 DISPID_IDISCFORMAT2TAO_EXPECTEDTABLEOFCONTENTS = 266;
		public const uint32 DISPID_IDISCFORMAT2TAO_CURRENTMEDIATYPE = 267;
		public const uint32 DISPID_IDISCFORMAT2TAO_CLIENTNAME = 270;
		public const uint32 DISPID_IDISCFORMAT2TAO_REQUESTEDWRITESPEED = 271;
		public const uint32 DISPID_IDISCFORMAT2TAO_REQUESTEDROTATIONTYPEISPURECAV = 272;
		public const uint32 DISPID_IDISCFORMAT2TAO_CURRENTWRITESPEED = 273;
		public const uint32 DISPID_IDISCFORMAT2TAO_CURRENTROTATIONTYPEISPURECAV = 274;
		public const uint32 DISPID_IDISCFORMAT2TAO_SUPPORTEDWRITESPEEDS = 275;
		public const uint32 DISPID_IDISCFORMAT2TAO_SUPPORTEDWRITESPEEDDESCRIPTORS = 276;
		public const uint32 DISPID_IDISCFORMAT2TAO_PREPAREMEDIA = 512;
		public const uint32 DISPID_IDISCFORMAT2TAO_ADDAUDIOTRACK = 513;
		public const uint32 DISPID_IDISCFORMAT2TAO_CANCELADDTRACK = 514;
		public const uint32 DISPID_IDISCFORMAT2TAO_FINISHMEDIA = 515;
		public const uint32 DISPID_IDISCFORMAT2TAO_SETWRITESPEED = 516;
		public const uint32 DISPID_DDISCFORMAT2TAOEVENTS_UPDATE = 512;
		public const uint32 DISPID_IDISCFORMAT2TAOEVENTARGS_CURRENTTRACKNUMBER = 768;
		public const uint32 DISPID_IDISCFORMAT2TAOEVENTARGS_CURRENTACTION = 769;
		public const uint32 DISPID_IDISCFORMAT2TAOEVENTARGS_ELAPSEDTIME = 770;
		public const uint32 DISPID_IDISCFORMAT2TAOEVENTARGS_ESTIMATEDREMAININGTIME = 771;
		public const uint32 DISPID_IDISCFORMAT2TAOEVENTARGS_ESTIMATEDTOTALTIME = 772;
		public const uint32 DISPID_IDISCFORMAT2RAWCD_RECORDER = 256;
		public const uint32 DISPID_IDISCFORMAT2RAWCD_BUFFERUNDERRUNFREEDISABLED = 258;
		public const uint32 DISPID_IDISCFORMAT2RAWCD_STARTOFNEXTSESSION = 259;
		public const uint32 DISPID_IDISCFORMAT2RAWCD_LASTPOSSIBLESTARTOFLEADOUT = 260;
		public const uint32 DISPID_IDISCFORMAT2RAWCD_CURRENTMEDIATYPE = 261;
		public const uint32 DISPID_IDISCFORMAT2RAWCD_SUPPORTEDDATASECTORTYPES = 264;
		public const uint32 DISPID_IDISCFORMAT2RAWCD_REQUESTEDDATASECTORTYPE = 265;
		public const uint32 DISPID_IDISCFORMAT2RAWCD_CLIENTNAME = 266;
		public const uint32 DISPID_IDISCFORMAT2RAWCD_REQUESTEDWRITESPEED = 267;
		public const uint32 DISPID_IDISCFORMAT2RAWCD_REQUESTEDROTATIONTYPEISPURECAV = 268;
		public const uint32 DISPID_IDISCFORMAT2RAWCD_CURRENTWRITESPEED = 269;
		public const uint32 DISPID_IDISCFORMAT2RAWCD_CURRENTROTATIONTYPEISPURECAV = 270;
		public const uint32 DISPID_IDISCFORMAT2RAWCD_SUPPORTEDWRITESPEEDS = 271;
		public const uint32 DISPID_IDISCFORMAT2RAWCD_SUPPORTEDWRITESPEEDDESCRIPTORS = 272;
		public const uint32 DISPID_IDISCFORMAT2RAWCD_PREPAREMEDIA = 512;
		public const uint32 DISPID_IDISCFORMAT2RAWCD_WRITEMEDIA = 513;
		public const uint32 DISPID_IDISCFORMAT2RAWCD_WRITEMEDIAWITHVALIDATION = 514;
		public const uint32 DISPID_IDISCFORMAT2RAWCD_CANCELWRITE = 515;
		public const uint32 DISPID_IDISCFORMAT2RAWCD_RELEASEMEDIA = 516;
		public const uint32 DISPID_IDISCFORMAT2RAWCD_SETWRITESPEED = 517;
		public const uint32 DISPID_DDISCFORMAT2RAWCDEVENTS_UPDATE = 512;
		public const uint32 DISPID_IDISCFORMAT2RAWCDEVENTARGS_CURRENTTRACKNUMBER = 768;
		public const uint32 DISPID_IDISCFORMAT2RAWCDEVENTARGS_CURRENTACTION = 769;
		public const uint32 DISPID_IDISCFORMAT2RAWCDEVENTARGS_ELAPSEDTIME = 768;
		public const uint32 DISPID_IDISCFORMAT2RAWCDEVENTARGS_ESTIMATEDREMAININGTIME = 769;
		public const uint32 DISPID_IDISCFORMAT2RAWCDEVENTARGS_ESTIMATEDTOTALTIME = 770;
		public const uint32 IMAPI_SECTORS_PER_SECOND_AT_1X_CD = 75;
		public const uint32 IMAPI_SECTORS_PER_SECOND_AT_1X_DVD = 680;
		public const uint32 IMAPI_SECTORS_PER_SECOND_AT_1X_BD = 2195;
		public const uint32 IMAPI_SECTORS_PER_SECOND_AT_1X_HD_DVD = 4568;
		public const uint32 DISPID_IMULTISESSION_SUPPORTEDONCURRENTMEDIA = 256;
		public const uint32 DISPID_IMULTISESSION_INUSE = 257;
		public const uint32 DISPID_IMULTISESSION_IMPORTRECORDER = 258;
		public const uint32 DISPID_IMULTISESSION_FIRSTDATASESSION = 512;
		public const uint32 DISPID_IMULTISESSION_STARTSECTOROFPREVIOUSSESSION = 513;
		public const uint32 DISPID_IMULTISESSION_LASTSECTOROFPREVIOUSSESSION = 514;
		public const uint32 DISPID_IMULTISESSION_NEXTWRITABLEADDRESS = 515;
		public const uint32 DISPID_IMULTISESSION_FREESECTORS = 516;
		public const uint32 DISPID_IMULTISESSION_WRITEUNITSIZE = 517;
		public const uint32 DISPID_IMULTISESSION_LASTWRITTENADDRESS = 518;
		public const uint32 DISPID_IMULTISESSION_SECTORSONMEDIA = 519;
		public const uint32 DISPID_IRAWCDIMAGECREATOR_CREATERESULTIMAGE = 512;
		public const uint32 DISPID_IRAWCDIMAGECREATOR_ADDTRACK = 513;
		public const uint32 DISPID_IRAWCDIMAGECREATOR_ADDSPECIALPREGAP = 514;
		public const uint32 DISPID_IRAWCDIMAGECREATOR_ADDSUBCODERWGENERATOR = 515;
		public const uint32 DISPID_IRAWCDIMAGECREATOR_RESULTINGIMAGETYPE = 256;
		public const uint32 DISPID_IRAWCDIMAGECREATOR_STARTOFLEADOUT = 257;
		public const uint32 DISPID_IRAWCDIMAGECREATOR_STARTOFLEADOUTLIMIT = 258;
		public const uint32 DISPID_IRAWCDIMAGECREATOR_DISABLEGAPLESSAUDIO = 259;
		public const uint32 DISPID_IRAWCDIMAGECREATOR_MEDIACATALOGNUMBER = 260;
		public const uint32 DISPID_IRAWCDIMAGECREATOR_STARTINGTRACKNUMBER = 261;
		public const uint32 DISPID_IRAWCDIMAGECREATOR_TRACKINFO = 262;
		public const uint32 DISPID_IRAWCDIMAGECREATOR_NUMBEROFEXISTINGTRACKS = 263;
		public const uint32 DISPID_IRAWCDIMAGECREATOR_USEDSECTORSONDISC = 264;
		public const uint32 DISPID_IRAWCDIMAGECREATOR_EXPECTEDTABLEOFCONTENTS = 265;
		public const uint32 DISPID_IRAWCDTRACKINFO_STARTINGLBA = 256;
		public const uint32 DISPID_IRAWCDTRACKINFO_SECTORCOUNT = 257;
		public const uint32 DISPID_IRAWCDTRACKINFO_TRACKNUMBER = 258;
		public const uint32 DISPID_IRAWCDTRACKINFO_SECTORTYPE = 259;
		public const uint32 DISPID_IRAWCDTRACKINFO_ISRC = 260;
		public const uint32 DISPID_IRAWCDTRACKINFO_DIGITALAUDIOCOPYSETTING = 261;
		public const uint32 DISPID_IRAWCDTRACKINFO_AUDIOHASPREEMPHASIS = 262;
		public const uint32 DISPID_IBLOCKRANGE_STARTLBA = 256;
		public const uint32 DISPID_IBLOCKRANGE_ENDLBA = 257;
		public const uint32 DISPID_IBLOCKRANGELIST_BLOCKRANGES = 256;
		public const uint32 IMAPILib2_MajorVersion = 1;
		public const uint32 IMAPILib2_MinorVersion = 0;
		public const uint32 IMAPI2FS_BOOT_ENTRY_COUNT_MAX = 32;
		public const uint32 DISPID_DFILESYSTEMIMAGEEVENTS_UPDATE = 256;
		public const uint32 DISPID_DFILESYSTEMIMAGEIMPORTEVENTS_UPDATEIMPORT = 257;
		public const uint32 IMAPI2FS_MajorVersion = 1;
		public const uint32 IMAPI2FS_MinorVersion = 0;
		public const uint32 MP_MSGCLASS_SYSTEM = 1;
		public const uint32 MP_MSGCLASS_REPLICATION = 2;
		public const uint32 MP_MSGCLASS_DELIVERY_REPORT = 3;
		public const uint32 MP_MSGCLASS_NONDELIVERY_REPORT = 4;
		public const uint32 MP_STATUS_SUCCESS = 0;
		public const uint32 MP_STATUS_RETRY = 1;
		public const uint32 MP_STATUS_ABORT_DELIVERY = 2;
		public const uint32 MP_STATUS_BAD_MAIL = 3;
		public const uint32 MP_STATUS_SUBMITTED = 4;
		public const uint32 MP_STATUS_CATEGORIZED = 5;
		public const uint32 MP_STATUS_ABANDON_DELIVERY = 6;
		public const uint32 RP_RECIP_FLAGS_RESERVED = 15;
		public const uint32 RP_DSN_NOTIFY_SUCCESS = 16777216;
		public const uint32 RP_DSN_NOTIFY_FAILURE = 33554432;
		public const uint32 RP_DSN_NOTIFY_DELAY = 67108864;
		public const uint32 RP_DSN_NOTIFY_NEVER = 134217728;
		public const uint32 RP_DSN_NOTIFY_MASK = 251658240;
		public const uint32 RP_HANDLED = 16;
		public const uint32 RP_GENERAL_FAILURE = 32;
		public const uint32 RP_DSN_HANDLED = 64;
		public const uint32 RP_DELIVERED = 272;
		public const uint32 RP_DSN_SENT_NDR = 1104;
		public const uint32 RP_FAILED = 2096;
		public const uint32 RP_UNRESOLVED = 4144;
		public const uint32 RP_ENPANDED = 8208;
		public const uint32 RP_EXPANDED = 8208;
		public const uint32 RP_DSN_SENT_DELAYED = 16384;
		public const uint32 RP_DSN_SENT_EXPANDED = 32832;
		public const uint32 RP_DSN_SENT_RELAYED = 65600;
		public const uint32 RP_DSN_SENT_DELIVERED = 131136;
		public const uint32 RP_REMOTE_MTA_NO_DSN = 524288;
		public const uint32 RP_ERROR_CONTEXT_STORE = 1048576;
		public const uint32 RP_ERROR_CONTEXT_CAT = 2097152;
		public const uint32 RP_ERROR_CONTEXT_MTA = 4194304;
		public const uint32 RP_VOLATILE_FLAGS_MASK = 4026531840;
		public const uint32 RP_DSN_NOTIFY_INVALID = 0;
		public const uint32 MPV_INBOUND_CUTOFF_EXCEEDED = 1;
		public const uint32 MPV_WRITE_CONTENT = 2;
		public const uint32 NMP_PROCESS_POST = 1;
		public const uint32 NMP_PROCESS_CONTROL = 2;
		public const uint32 NMP_PROCESS_MODERATOR = 4;
		public const Guid GUID_SMTP_SOURCE_TYPE = .(0xfb65c4dc, 0xe468, 0x11d1, 0xaa, 0x67, 0x00, 0xc0, 0x4f, 0xa3, 0x45, 0xf6);
		public const Guid GUID_SMTPSVC_SOURCE = .(0x1b3c0666, 0xe470, 0x11d1, 0xaa, 0x67, 0x00, 0xc0, 0x4f, 0xa3, 0x45, 0xf6);
		public const Guid CATID_SMTP_ON_INBOUND_COMMAND = .(0xf6628c8d, 0x0d5e, 0x11d2, 0xaa, 0x68, 0x00, 0xc0, 0x4f, 0xa3, 0x5b, 0x82);
		public const Guid CATID_SMTP_ON_SERVER_RESPONSE = .(0xf6628c8e, 0x0d5e, 0x11d2, 0xaa, 0x68, 0x00, 0xc0, 0x4f, 0xa3, 0x5b, 0x82);
		public const Guid CATID_SMTP_ON_SESSION_START = .(0xf6628c8f, 0x0d5e, 0x11d2, 0xaa, 0x68, 0x00, 0xc0, 0x4f, 0xa3, 0x5b, 0x82);
		public const Guid CATID_SMTP_ON_MESSAGE_START = .(0xf6628c90, 0x0d5e, 0x11d2, 0xaa, 0x68, 0x00, 0xc0, 0x4f, 0xa3, 0x5b, 0x82);
		public const Guid CATID_SMTP_ON_PER_RECIPIENT = .(0xf6628c91, 0x0d5e, 0x11d2, 0xaa, 0x68, 0x00, 0xc0, 0x4f, 0xa3, 0x5b, 0x82);
		public const Guid CATID_SMTP_ON_BEFORE_DATA = .(0xf6628c92, 0x0d5e, 0x11d2, 0xaa, 0x68, 0x00, 0xc0, 0x4f, 0xa3, 0x5b, 0x82);
		public const Guid CATID_SMTP_ON_SESSION_END = .(0xf6628c93, 0x0d5e, 0x11d2, 0xaa, 0x68, 0x00, 0xc0, 0x4f, 0xa3, 0x5b, 0x82);
		public const Guid CATID_SMTP_STORE_DRIVER = .(0x59175850, 0xe533, 0x11d1, 0xaa, 0x67, 0x00, 0xc0, 0x4f, 0xa3, 0x45, 0xf6);
		public const Guid CATID_SMTP_TRANSPORT_SUBMISSION = .(0xff3caa23, 0x00b9, 0x11d2, 0x9d, 0xfb, 0x00, 0xc0, 0x4f, 0xa3, 0x22, 0xba);
		public const Guid CATID_SMTP_TRANSPORT_PRECATEGORIZE = .(0xa3acfb0d, 0x83ff, 0x11d2, 0x9e, 0x14, 0x00, 0xc0, 0x4f, 0xa3, 0x22, 0xba);
		public const Guid CATID_SMTP_TRANSPORT_CATEGORIZE = .(0x960252a3, 0x0a3a, 0x11d2, 0x9e, 0x00, 0x00, 0xc0, 0x4f, 0xa3, 0x22, 0xba);
		public const Guid CATID_SMTP_TRANSPORT_POSTCATEGORIZE = .(0x76719654, 0x05a6, 0x11d2, 0x9d, 0xfd, 0x00, 0xc0, 0x4f, 0xa3, 0x22, 0xba);
		public const Guid CATID_SMTP_TRANSPORT_ROUTER = .(0x283430c9, 0x1850, 0x11d2, 0x9e, 0x03, 0x00, 0xc0, 0x4f, 0xa3, 0x22, 0xba);
		public const Guid CATID_SMTP_MSGTRACKLOG = .(0xc6df52aa, 0x7db0, 0x11d2, 0x94, 0xf4, 0x00, 0xc0, 0x4f, 0x79, 0xf1, 0xd6);
		public const Guid CATID_SMTP_DNSRESOLVERRECORDSINK = .(0xbd0b4366, 0x8e03, 0x11d2, 0x94, 0xf6, 0x00, 0xc0, 0x4f, 0x79, 0xf1, 0xd6);
		public const Guid CATID_SMTP_MAXMSGSIZE = .(0xebf159de, 0xa67e, 0x11d2, 0x94, 0xf7, 0x00, 0xc0, 0x4f, 0x79, 0xf1, 0xd6);
		public const Guid CATID_SMTP_LOG = .(0x93d0a538, 0x2c1e, 0x4b68, 0xa7, 0xc9, 0xd7, 0x3a, 0x8a, 0xa6, 0xee, 0x97);
		public const Guid CATID_SMTP_GET_AUX_DOMAIN_INFO_FLAGS = .(0x84ff368a, 0xfab3, 0x43d7, 0xbc, 0xdf, 0x69, 0x2c, 0x5b, 0x46, 0xe6, 0xb1);
		public const Guid CLSID_SmtpCat = .(0xb23c35b7, 0x9219, 0x11d2, 0x9e, 0x17, 0x00, 0xc0, 0x4f, 0xa3, 0x22, 0xba);
		public const Guid CATID_SMTP_DSN = .(0x22b55731, 0xf5f8, 0x4d23, 0xbd, 0x8f, 0x87, 0xb5, 0x23, 0x71, 0xa7, 0x3a);
		public const HRESULT IMAPI_S_PROPERTIESIGNORED = 262656;
		public const HRESULT IMAPI_S_BUFFER_TO_SMALL = 262657;
		public const HRESULT IMAPI_E_NOTOPENED = -2147220981;
		public const HRESULT IMAPI_E_NOTINITIALIZED = -2147220980;
		public const HRESULT IMAPI_E_USERABORT = -2147220979;
		public const HRESULT IMAPI_E_GENERIC = -2147220978;
		public const HRESULT IMAPI_E_MEDIUM_NOTPRESENT = -2147220977;
		public const HRESULT IMAPI_E_MEDIUM_INVALIDTYPE = -2147220976;
		public const HRESULT IMAPI_E_DEVICE_NOPROPERTIES = -2147220975;
		public const HRESULT IMAPI_E_DEVICE_NOTACCESSIBLE = -2147220974;
		public const HRESULT IMAPI_E_DEVICE_NOTPRESENT = -2147220973;
		public const HRESULT IMAPI_E_DEVICE_INVALIDTYPE = -2147220972;
		public const HRESULT IMAPI_E_INITIALIZE_WRITE = -2147220971;
		public const HRESULT IMAPI_E_INITIALIZE_ENDWRITE = -2147220970;
		public const HRESULT IMAPI_E_FILESYSTEM = -2147220969;
		public const HRESULT IMAPI_E_FILEACCESS = -2147220968;
		public const HRESULT IMAPI_E_DISCINFO = -2147220967;
		public const HRESULT IMAPI_E_TRACKNOTOPEN = -2147220966;
		public const HRESULT IMAPI_E_TRACKOPEN = -2147220965;
		public const HRESULT IMAPI_E_DISCFULL = -2147220964;
		public const HRESULT IMAPI_E_BADJOLIETNAME = -2147220963;
		public const HRESULT IMAPI_E_INVALIDIMAGE = -2147220962;
		public const HRESULT IMAPI_E_NOACTIVEFORMAT = -2147220961;
		public const HRESULT IMAPI_E_NOACTIVERECORDER = -2147220960;
		public const HRESULT IMAPI_E_WRONGFORMAT = -2147220959;
		public const HRESULT IMAPI_E_ALREADYOPEN = -2147220958;
		public const HRESULT IMAPI_E_WRONGDISC = -2147220957;
		public const HRESULT IMAPI_E_FILEEXISTS = -2147220956;
		public const HRESULT IMAPI_E_STASHINUSE = -2147220955;
		public const HRESULT IMAPI_E_DEVICE_STILL_IN_USE = -2147220954;
		public const HRESULT IMAPI_E_LOSS_OF_STREAMING = -2147220953;
		public const HRESULT IMAPI_E_COMPRESSEDSTASH = -2147220952;
		public const HRESULT IMAPI_E_ENCRYPTEDSTASH = -2147220951;
		public const HRESULT IMAPI_E_NOTENOUGHDISKFORSTASH = -2147220950;
		public const HRESULT IMAPI_E_REMOVABLESTASH = -2147220949;
		public const HRESULT IMAPI_E_CANNOT_WRITE_TO_MEDIA = -2147220948;
		public const HRESULT IMAPI_E_TRACK_NOT_BIG_ENOUGH = -2147220947;
		public const HRESULT IMAPI_E_BOOTIMAGE_AND_NONBLANK_DISC = -2147220946;
		
		// --- Enums ---
		
		[AllowDuplicates]
		public enum DISC_RECORDER_STATE_FLAGS : uint32
		{
			RECORDER_BURNING = 2,
			RECORDER_DOING_NOTHING = 0,
			RECORDER_OPENED = 1,
		}
		[AllowDuplicates]
		public enum IMAPI_MEDIA_PHYSICAL_TYPE : int32
		{
			IMAPI_MEDIA_TYPE_UNKNOWN = 0,
			IMAPI_MEDIA_TYPE_CDROM = 1,
			IMAPI_MEDIA_TYPE_CDR = 2,
			IMAPI_MEDIA_TYPE_CDRW = 3,
			IMAPI_MEDIA_TYPE_DVDROM = 4,
			IMAPI_MEDIA_TYPE_DVDRAM = 5,
			IMAPI_MEDIA_TYPE_DVDPLUSR = 6,
			IMAPI_MEDIA_TYPE_DVDPLUSRW = 7,
			IMAPI_MEDIA_TYPE_DVDPLUSR_DUALLAYER = 8,
			IMAPI_MEDIA_TYPE_DVDDASHR = 9,
			IMAPI_MEDIA_TYPE_DVDDASHRW = 10,
			IMAPI_MEDIA_TYPE_DVDDASHR_DUALLAYER = 11,
			IMAPI_MEDIA_TYPE_DISK = 12,
			IMAPI_MEDIA_TYPE_DVDPLUSRW_DUALLAYER = 13,
			IMAPI_MEDIA_TYPE_HDDVDROM = 14,
			IMAPI_MEDIA_TYPE_HDDVDR = 15,
			IMAPI_MEDIA_TYPE_HDDVDRAM = 16,
			IMAPI_MEDIA_TYPE_BDROM = 17,
			IMAPI_MEDIA_TYPE_BDR = 18,
			IMAPI_MEDIA_TYPE_BDRE = 19,
			IMAPI_MEDIA_TYPE_MAX = 19,
		}
		[AllowDuplicates]
		public enum IMAPI_MEDIA_WRITE_PROTECT_STATE : int32
		{
			IMAPI_WRITEPROTECTED_UNTIL_POWERDOWN = 1,
			IMAPI_WRITEPROTECTED_BY_CARTRIDGE = 2,
			IMAPI_WRITEPROTECTED_BY_MEDIA_SPECIFIC_REASON = 4,
			IMAPI_WRITEPROTECTED_BY_SOFTWARE_WRITE_PROTECT = 8,
			IMAPI_WRITEPROTECTED_BY_DISC_CONTROL_BLOCK = 16,
			IMAPI_WRITEPROTECTED_READ_ONLY_MEDIA = 16384,
		}
		[AllowDuplicates]
		public enum IMAPI_READ_TRACK_ADDRESS_TYPE : int32
		{
			IMAPI_READ_TRACK_ADDRESS_TYPE_LBA = 0,
			IMAPI_READ_TRACK_ADDRESS_TYPE_TRACK = 1,
			IMAPI_READ_TRACK_ADDRESS_TYPE_SESSION = 2,
		}
		[AllowDuplicates]
		public enum IMAPI_MODE_PAGE_REQUEST_TYPE : int32
		{
			IMAPI_MODE_PAGE_REQUEST_TYPE_CURRENT_VALUES = 0,
			IMAPI_MODE_PAGE_REQUEST_TYPE_CHANGEABLE_VALUES = 1,
			IMAPI_MODE_PAGE_REQUEST_TYPE_DEFAULT_VALUES = 2,
			IMAPI_MODE_PAGE_REQUEST_TYPE_SAVED_VALUES = 3,
		}
		[AllowDuplicates]
		public enum IMAPI_MODE_PAGE_TYPE : int32
		{
			IMAPI_MODE_PAGE_TYPE_READ_WRITE_ERROR_RECOVERY = 1,
			IMAPI_MODE_PAGE_TYPE_MRW = 3,
			IMAPI_MODE_PAGE_TYPE_WRITE_PARAMETERS = 5,
			IMAPI_MODE_PAGE_TYPE_CACHING = 8,
			IMAPI_MODE_PAGE_TYPE_INFORMATIONAL_EXCEPTIONS = 28,
			IMAPI_MODE_PAGE_TYPE_TIMEOUT_AND_PROTECT = 29,
			IMAPI_MODE_PAGE_TYPE_POWER_CONDITION = 26,
			IMAPI_MODE_PAGE_TYPE_LEGACY_CAPABILITIES = 42,
		}
		[AllowDuplicates]
		public enum IMAPI_FEATURE_PAGE_TYPE : int32
		{
			IMAPI_FEATURE_PAGE_TYPE_PROFILE_LIST = 0,
			IMAPI_FEATURE_PAGE_TYPE_CORE = 1,
			IMAPI_FEATURE_PAGE_TYPE_MORPHING = 2,
			IMAPI_FEATURE_PAGE_TYPE_REMOVABLE_MEDIUM = 3,
			IMAPI_FEATURE_PAGE_TYPE_WRITE_PROTECT = 4,
			IMAPI_FEATURE_PAGE_TYPE_RANDOMLY_READABLE = 16,
			IMAPI_FEATURE_PAGE_TYPE_CD_MULTIREAD = 29,
			IMAPI_FEATURE_PAGE_TYPE_CD_READ = 30,
			IMAPI_FEATURE_PAGE_TYPE_DVD_READ = 31,
			IMAPI_FEATURE_PAGE_TYPE_RANDOMLY_WRITABLE = 32,
			IMAPI_FEATURE_PAGE_TYPE_INCREMENTAL_STREAMING_WRITABLE = 33,
			IMAPI_FEATURE_PAGE_TYPE_SECTOR_ERASABLE = 34,
			IMAPI_FEATURE_PAGE_TYPE_FORMATTABLE = 35,
			IMAPI_FEATURE_PAGE_TYPE_HARDWARE_DEFECT_MANAGEMENT = 36,
			IMAPI_FEATURE_PAGE_TYPE_WRITE_ONCE = 37,
			IMAPI_FEATURE_PAGE_TYPE_RESTRICTED_OVERWRITE = 38,
			IMAPI_FEATURE_PAGE_TYPE_CDRW_CAV_WRITE = 39,
			IMAPI_FEATURE_PAGE_TYPE_MRW = 40,
			IMAPI_FEATURE_PAGE_TYPE_ENHANCED_DEFECT_REPORTING = 41,
			IMAPI_FEATURE_PAGE_TYPE_DVD_PLUS_RW = 42,
			IMAPI_FEATURE_PAGE_TYPE_DVD_PLUS_R = 43,
			IMAPI_FEATURE_PAGE_TYPE_RIGID_RESTRICTED_OVERWRITE = 44,
			IMAPI_FEATURE_PAGE_TYPE_CD_TRACK_AT_ONCE = 45,
			IMAPI_FEATURE_PAGE_TYPE_CD_MASTERING = 46,
			IMAPI_FEATURE_PAGE_TYPE_DVD_DASH_WRITE = 47,
			IMAPI_FEATURE_PAGE_TYPE_DOUBLE_DENSITY_CD_READ = 48,
			IMAPI_FEATURE_PAGE_TYPE_DOUBLE_DENSITY_CD_R_WRITE = 49,
			IMAPI_FEATURE_PAGE_TYPE_DOUBLE_DENSITY_CD_RW_WRITE = 50,
			IMAPI_FEATURE_PAGE_TYPE_LAYER_JUMP_RECORDING = 51,
			IMAPI_FEATURE_PAGE_TYPE_CD_RW_MEDIA_WRITE_SUPPORT = 55,
			IMAPI_FEATURE_PAGE_TYPE_BD_PSEUDO_OVERWRITE = 56,
			IMAPI_FEATURE_PAGE_TYPE_DVD_PLUS_R_DUAL_LAYER = 59,
			IMAPI_FEATURE_PAGE_TYPE_BD_READ = 64,
			IMAPI_FEATURE_PAGE_TYPE_BD_WRITE = 65,
			IMAPI_FEATURE_PAGE_TYPE_HD_DVD_READ = 80,
			IMAPI_FEATURE_PAGE_TYPE_HD_DVD_WRITE = 81,
			IMAPI_FEATURE_PAGE_TYPE_POWER_MANAGEMENT = 256,
			IMAPI_FEATURE_PAGE_TYPE_SMART = 257,
			IMAPI_FEATURE_PAGE_TYPE_EMBEDDED_CHANGER = 258,
			IMAPI_FEATURE_PAGE_TYPE_CD_ANALOG_PLAY = 259,
			IMAPI_FEATURE_PAGE_TYPE_MICROCODE_UPDATE = 260,
			IMAPI_FEATURE_PAGE_TYPE_TIMEOUT = 261,
			IMAPI_FEATURE_PAGE_TYPE_DVD_CSS = 262,
			IMAPI_FEATURE_PAGE_TYPE_REAL_TIME_STREAMING = 263,
			IMAPI_FEATURE_PAGE_TYPE_LOGICAL_UNIT_SERIAL_NUMBER = 264,
			IMAPI_FEATURE_PAGE_TYPE_MEDIA_SERIAL_NUMBER = 265,
			IMAPI_FEATURE_PAGE_TYPE_DISC_CONTROL_BLOCKS = 266,
			IMAPI_FEATURE_PAGE_TYPE_DVD_CPRM = 267,
			IMAPI_FEATURE_PAGE_TYPE_FIRMWARE_INFORMATION = 268,
			IMAPI_FEATURE_PAGE_TYPE_AACS = 269,
			IMAPI_FEATURE_PAGE_TYPE_VCPS = 272,
		}
		[AllowDuplicates]
		public enum IMAPI_PROFILE_TYPE : int32
		{
			IMAPI_PROFILE_TYPE_INVALID = 0,
			IMAPI_PROFILE_TYPE_NON_REMOVABLE_DISK = 1,
			IMAPI_PROFILE_TYPE_REMOVABLE_DISK = 2,
			IMAPI_PROFILE_TYPE_MO_ERASABLE = 3,
			IMAPI_PROFILE_TYPE_MO_WRITE_ONCE = 4,
			IMAPI_PROFILE_TYPE_AS_MO = 5,
			IMAPI_PROFILE_TYPE_CDROM = 8,
			IMAPI_PROFILE_TYPE_CD_RECORDABLE = 9,
			IMAPI_PROFILE_TYPE_CD_REWRITABLE = 10,
			IMAPI_PROFILE_TYPE_DVDROM = 16,
			IMAPI_PROFILE_TYPE_DVD_DASH_RECORDABLE = 17,
			IMAPI_PROFILE_TYPE_DVD_RAM = 18,
			IMAPI_PROFILE_TYPE_DVD_DASH_REWRITABLE = 19,
			IMAPI_PROFILE_TYPE_DVD_DASH_RW_SEQUENTIAL = 20,
			IMAPI_PROFILE_TYPE_DVD_DASH_R_DUAL_SEQUENTIAL = 21,
			IMAPI_PROFILE_TYPE_DVD_DASH_R_DUAL_LAYER_JUMP = 22,
			IMAPI_PROFILE_TYPE_DVD_PLUS_RW = 26,
			IMAPI_PROFILE_TYPE_DVD_PLUS_R = 27,
			IMAPI_PROFILE_TYPE_DDCDROM = 32,
			IMAPI_PROFILE_TYPE_DDCD_RECORDABLE = 33,
			IMAPI_PROFILE_TYPE_DDCD_REWRITABLE = 34,
			IMAPI_PROFILE_TYPE_DVD_PLUS_RW_DUAL = 42,
			IMAPI_PROFILE_TYPE_DVD_PLUS_R_DUAL = 43,
			IMAPI_PROFILE_TYPE_BD_ROM = 64,
			IMAPI_PROFILE_TYPE_BD_R_SEQUENTIAL = 65,
			IMAPI_PROFILE_TYPE_BD_R_RANDOM_RECORDING = 66,
			IMAPI_PROFILE_TYPE_BD_REWRITABLE = 67,
			IMAPI_PROFILE_TYPE_HD_DVD_ROM = 80,
			IMAPI_PROFILE_TYPE_HD_DVD_RECORDABLE = 81,
			IMAPI_PROFILE_TYPE_HD_DVD_RAM = 82,
			IMAPI_PROFILE_TYPE_NON_STANDARD = 65535,
		}
		[AllowDuplicates]
		public enum IMAPI_FORMAT2_DATA_WRITE_ACTION : int32
		{
			IMAPI_FORMAT2_DATA_WRITE_ACTION_VALIDATING_MEDIA = 0,
			IMAPI_FORMAT2_DATA_WRITE_ACTION_FORMATTING_MEDIA = 1,
			IMAPI_FORMAT2_DATA_WRITE_ACTION_INITIALIZING_HARDWARE = 2,
			IMAPI_FORMAT2_DATA_WRITE_ACTION_CALIBRATING_POWER = 3,
			IMAPI_FORMAT2_DATA_WRITE_ACTION_WRITING_DATA = 4,
			IMAPI_FORMAT2_DATA_WRITE_ACTION_FINALIZATION = 5,
			IMAPI_FORMAT2_DATA_WRITE_ACTION_COMPLETED = 6,
			IMAPI_FORMAT2_DATA_WRITE_ACTION_VERIFYING = 7,
		}
		[AllowDuplicates]
		public enum IMAPI_FORMAT2_DATA_MEDIA_STATE : int32
		{
			IMAPI_FORMAT2_DATA_MEDIA_STATE_UNKNOWN = 0,
			IMAPI_FORMAT2_DATA_MEDIA_STATE_INFORMATIONAL_MASK = 15,
			IMAPI_FORMAT2_DATA_MEDIA_STATE_UNSUPPORTED_MASK = 64512,
			IMAPI_FORMAT2_DATA_MEDIA_STATE_OVERWRITE_ONLY = 1,
			IMAPI_FORMAT2_DATA_MEDIA_STATE_RANDOMLY_WRITABLE = 1,
			IMAPI_FORMAT2_DATA_MEDIA_STATE_BLANK = 2,
			IMAPI_FORMAT2_DATA_MEDIA_STATE_APPENDABLE = 4,
			IMAPI_FORMAT2_DATA_MEDIA_STATE_FINAL_SESSION = 8,
			IMAPI_FORMAT2_DATA_MEDIA_STATE_DAMAGED = 1024,
			IMAPI_FORMAT2_DATA_MEDIA_STATE_ERASE_REQUIRED = 2048,
			IMAPI_FORMAT2_DATA_MEDIA_STATE_NON_EMPTY_SESSION = 4096,
			IMAPI_FORMAT2_DATA_MEDIA_STATE_WRITE_PROTECTED = 8192,
			IMAPI_FORMAT2_DATA_MEDIA_STATE_FINALIZED = 16384,
			IMAPI_FORMAT2_DATA_MEDIA_STATE_UNSUPPORTED_MEDIA = 32768,
		}
		[AllowDuplicates]
		public enum IMAPI_FORMAT2_TAO_WRITE_ACTION : int32
		{
			IMAPI_FORMAT2_TAO_WRITE_ACTION_UNKNOWN = 0,
			IMAPI_FORMAT2_TAO_WRITE_ACTION_PREPARING = 1,
			IMAPI_FORMAT2_TAO_WRITE_ACTION_WRITING = 2,
			IMAPI_FORMAT2_TAO_WRITE_ACTION_FINISHING = 3,
			IMAPI_FORMAT2_TAO_WRITE_ACTION_VERIFYING = 4,
		}
		[AllowDuplicates]
		public enum IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE : int32
		{
			IMAPI_FORMAT2_RAW_CD_SUBCODE_PQ_ONLY = 1,
			IMAPI_FORMAT2_RAW_CD_SUBCODE_IS_COOKED = 2,
			IMAPI_FORMAT2_RAW_CD_SUBCODE_IS_RAW = 3,
		}
		[AllowDuplicates]
		public enum IMAPI_FORMAT2_RAW_CD_WRITE_ACTION : int32
		{
			IMAPI_FORMAT2_RAW_CD_WRITE_ACTION_UNKNOWN = 0,
			IMAPI_FORMAT2_RAW_CD_WRITE_ACTION_PREPARING = 1,
			IMAPI_FORMAT2_RAW_CD_WRITE_ACTION_WRITING = 2,
			IMAPI_FORMAT2_RAW_CD_WRITE_ACTION_FINISHING = 3,
		}
		[AllowDuplicates]
		public enum IMAPI_CD_SECTOR_TYPE : int32
		{
			IMAPI_CD_SECTOR_AUDIO = 0,
			IMAPI_CD_SECTOR_MODE_ZERO = 1,
			IMAPI_CD_SECTOR_MODE1 = 2,
			IMAPI_CD_SECTOR_MODE2FORM0 = 3,
			IMAPI_CD_SECTOR_MODE2FORM1 = 4,
			IMAPI_CD_SECTOR_MODE2FORM2 = 5,
			IMAPI_CD_SECTOR_MODE1RAW = 6,
			IMAPI_CD_SECTOR_MODE2FORM0RAW = 7,
			IMAPI_CD_SECTOR_MODE2FORM1RAW = 8,
			IMAPI_CD_SECTOR_MODE2FORM2RAW = 9,
		}
		[AllowDuplicates]
		public enum IMAPI_CD_TRACK_DIGITAL_COPY_SETTING : int32
		{
			IMAPI_CD_TRACK_DIGITAL_COPY_PERMITTED = 0,
			IMAPI_CD_TRACK_DIGITAL_COPY_PROHIBITED = 1,
			IMAPI_CD_TRACK_DIGITAL_COPY_SCMS = 2,
		}
		[AllowDuplicates]
		public enum IMAPI_BURN_VERIFICATION_LEVEL : int32
		{
			IMAPI_BURN_VERIFICATION_NONE = 0,
			IMAPI_BURN_VERIFICATION_QUICK = 1,
			IMAPI_BURN_VERIFICATION_FULL = 2,
		}
		[AllowDuplicates]
		public enum FsiItemType : int32
		{
			FsiItemNotFound = 0,
			FsiItemDirectory = 1,
			FsiItemFile = 2,
		}
		[AllowDuplicates]
		public enum FsiFileSystems : int32
		{
			FsiFileSystemNone = 0,
			FsiFileSystemISO9660 = 1,
			FsiFileSystemJoliet = 2,
			FsiFileSystemUDF = 4,
			FsiFileSystemUnknown = 1073741824,
		}
		[AllowDuplicates]
		public enum EmulationType : int32
		{
			EmulationNone = 0,
			Emulation12MFloppy = 1,
			Emulation144MFloppy = 2,
			Emulation288MFloppy = 3,
			EmulationHardDisk = 4,
		}
		[AllowDuplicates]
		public enum PlatformId : int32
		{
			PlatformX86 = 0,
			PlatformPowerPC = 1,
			PlatformMac = 2,
			PlatformEFI = 239,
		}
		[AllowDuplicates]
		public enum MEDIA_TYPES : int32
		{
			MEDIA_CDDA_CDROM = 1,
			MEDIA_CD_ROM_XA = 2,
			MEDIA_CD_I = 3,
			MEDIA_CD_EXTRA = 4,
			MEDIA_CD_OTHER = 5,
			MEDIA_SPECIAL = 6,
		}
		[AllowDuplicates]
		public enum MEDIA_FLAGS : int32
		{
			MEDIA_BLANK = 1,
			MEDIA_RW = 2,
			MEDIA_WRITABLE = 4,
			MEDIA_FORMAT_UNUSABLE_BY_IMAPI = 8,
		}
		[AllowDuplicates]
		public enum RECORDER_TYPES : int32
		{
			RECORDER_CDR = 1,
			RECORDER_CDRW = 2,
		}
		[AllowDuplicates]
		public enum IMMPID_MP_ENUM : int32
		{
			IMMPID_MP_BEFORE__ = 4095,
			IMMPID_MP_RECIPIENT_LIST = 4096,
			IMMPID_MP_CONTENT_FILE_NAME = 4097,
			IMMPID_MP_SENDER_ADDRESS_SMTP = 4098,
			IMMPID_MP_SENDER_ADDRESS_X500 = 4099,
			IMMPID_MP_SENDER_ADDRESS_X400 = 4100,
			IMMPID_MP_SENDER_ADDRESS_LEGACY_EX_DN = 4101,
			IMMPID_MP_DOMAIN_LIST = 4102,
			IMMPID_MP_PICKUP_FILE_NAME = 4103,
			IMMPID_MP_AUTHENTICATED_USER_NAME = 4104,
			IMMPID_MP_CONNECTION_IP_ADDRESS = 4105,
			IMMPID_MP_HELO_DOMAIN = 4106,
			IMMPID_MP_EIGHTBIT_MIME_OPTION = 4107,
			IMMPID_MP_CHUNKING_OPTION = 4108,
			IMMPID_MP_BINARYMIME_OPTION = 4109,
			IMMPID_MP_REMOTE_AUTHENTICATION_TYPE = 4110,
			IMMPID_MP_ERROR_CODE = 4111,
			IMMPID_MP_DSN_ENVID_VALUE = 4112,
			IMMPID_MP_DSN_RET_VALUE = 4113,
			IMMPID_MP_REMOTE_SERVER_DSN_CAPABLE = 4114,
			IMMPID_MP_ARRIVAL_TIME = 4115,
			IMMPID_MP_MESSAGE_STATUS = 4116,
			IMMPID_MP_EXPIRE_DELAY = 4117,
			IMMPID_MP_EXPIRE_NDR = 4118,
			IMMPID_MP_LOCAL_EXPIRE_DELAY = 4119,
			IMMPID_MP_LOCAL_EXPIRE_NDR = 4120,
			IMMPID_MP_ARRIVAL_FILETIME = 4121,
			IMMPID_MP_HR_CAT_STATUS = 4122,
			IMMPID_MP_MSG_GUID = 4123,
			IMMPID_MP_SUPERSEDES_MSG_GUID = 4124,
			IMMPID_MP_SCANNED_FOR_CRLF_DOT_CRLF = 4125,
			IMMPID_MP_FOUND_EMBEDDED_CRLF_DOT_CRLF = 4126,
			IMMPID_MP_MSG_SIZE_HINT = 4127,
			IMMPID_MP_RFC822_MSG_ID = 4128,
			IMMPID_MP_RFC822_MSG_SUBJECT = 4129,
			IMMPID_MP_RFC822_FROM_ADDRESS = 4130,
			IMMPID_MP_RFC822_TO_ADDRESS = 4131,
			IMMPID_MP_RFC822_CC_ADDRESS = 4132,
			IMMPID_MP_RFC822_BCC_ADDRESS = 4133,
			IMMPID_MP_CONNECTION_SERVER_IP_ADDRESS = 4134,
			IMMPID_MP_SERVER_NAME = 4135,
			IMMPID_MP_SERVER_VERSION = 4136,
			IMMPID_MP_NUM_RECIPIENTS = 4137,
			IMMPID_MP_X_PRIORITY = 4138,
			IMMPID_MP_FROM_ADDRESS = 4139,
			IMMPID_MP_SENDER_ADDRESS = 4140,
			IMMPID_MP_DEFERRED_DELIVERY_FILETIME = 4141,
			IMMPID_MP_SENDER_ADDRESS_OTHER = 4142,
			IMMPID_MP_ORIGINAL_ARRIVAL_TIME = 4143,
			IMMPID_MP_MSGCLASS = 4144,
			IMMPID_MP_CONTENT_TYPE = 4145,
			IMMPID_MP_ENCRYPTION_TYPE = 4146,
			IMMPID_MP_CONNECTION_SERVER_PORT = 4147,
			IMMPID_MP_CLIENT_AUTH_USER = 4148,
			IMMPID_MP_CLIENT_AUTH_TYPE = 4149,
			IMMPID_MP_CRC_GLOBAL = 4150,
			IMMPID_MP_CRC_RECIPS = 4151,
			IMMPID_MP_INBOUND_MAIL_FROM_AUTH = 4152,
			IMMPID_MP_AFTER__ = 4153,
		}
		[AllowDuplicates]
		public enum IMMPID_RP_ENUM : int32
		{
			IMMPID_RP_BEFORE__ = 8191,
			IMMPID_RP_DSN_NOTIFY_SUCCESS = 8192,
			IMMPID_RP_DSN_NOTIFY_INVALID = 8193,
			IMMPID_RP_ADDRESS_TYPE = 8194,
			IMMPID_RP_ADDRESS = 8195,
			IMMPID_RP_ADDRESS_TYPE_SMTP = 8196,
			IMMPID_RP_ERROR_CODE = 8197,
			IMMPID_RP_ERROR_STRING = 8198,
			IMMPID_RP_DSN_NOTIFY_VALUE = 8199,
			IMMPID_RP_DSN_ORCPT_VALUE = 8200,
			IMMPID_RP_ADDRESS_SMTP = 8201,
			IMMPID_RP_ADDRESS_X400 = 8202,
			IMMPID_RP_ADDRESS_X500 = 8203,
			IMMPID_RP_LEGACY_EX_DN = 8204,
			IMMPID_RP_RECIPIENT_FLAGS = 8205,
			IMMPID_RP_SMTP_STATUS_STRING = 8206,
			IMMPID_RP_DSN_PRE_CAT_ADDRESS = 8207,
			IMMPID_RP_MDB_GUID = 8208,
			IMMPID_RP_USER_GUID = 8209,
			IMMPID_RP_DOMAIN = 8210,
			IMMPID_RP_ADDRESS_OTHER = 8211,
			IMMPID_RP_DISPLAY_NAME = 8212,
			IMMPID_RP_AFTER__ = 8213,
		}
		[AllowDuplicates]
		public enum IMMPID_MPV_ENUM : int32
		{
			IMMPID_MPV_BEFORE__ = 12287,
			IMMPID_MPV_STORE_DRIVER_HANDLE = 12288,
			IMMPID_MPV_MESSAGE_CREATION_FLAGS = 12289,
			IMMPID_MPV_MESSAGE_OPEN_HANDLES = 12290,
			IMMPID_MPV_TOTAL_OPEN_HANDLES = 12291,
			IMMPID_MPV_TOTAL_OPEN_PROPERTY_STREAM_HANDLES = 12292,
			IMMPID_MPV_TOTAL_OPEN_CONTENT_HANDLES = 12293,
			IMMPID_MPV_AFTER__ = 12294,
		}
		[AllowDuplicates]
		public enum IMMPID_RPV_ENUM : int32
		{
			IMMPID_RPV_BEFORE__ = 16383,
			IMMPID_RPV_DONT_DELIVER = 16384,
			IMMPID_RPV_NO_NAME_COLLISIONS = 16385,
			IMMPID_RPV_AFTER__ = 16386,
		}
		[AllowDuplicates]
		public enum IMMPID_NMP_ENUM : int32
		{
			IMMPID_NMP_BEFORE__ = 24575,
			IMMPID_NMP_SECONDARY_GROUPS = 24576,
			IMMPID_NMP_SECONDARY_ARTNUM = 24577,
			IMMPID_NMP_PRIMARY_GROUP = 24578,
			IMMPID_NMP_PRIMARY_ARTID = 24579,
			IMMPID_NMP_POST_TOKEN = 24580,
			IMMPID_NMP_NEWSGROUP_LIST = 24581,
			IMMPID_NMP_HEADERS = 24582,
			IMMPID_NMP_NNTP_PROCESSING = 24583,
			IMMPID_NMP_NNTP_APPROVED_HEADER = 24584,
			IMMPID_NMP_AFTER__ = 24585,
		}
		[AllowDuplicates]
		public enum IMMPID_CPV_ENUM : int32
		{
			IMMPID_CPV_BEFORE__ = 32767,
			IMMPID_CP_START = 32768,
			IMMPID_CPV_AFTER__ = 32769,
		}
		
		// --- Function Pointers ---
		
		public function void MSGCALLRELEASE(uint32 ulCallerData, IMessage* lpMessage);
		
		// --- Structs ---
		
		[CRepr]
		public struct _MSGSESS
		{
		}
		[CRepr]
		public struct SPropAttrArray
		{
			public uint32 cValues;
			public uint32[] aPropAttr;
		}
		[CRepr]
		public struct IMMP_MPV_STORE_DRIVER_HANDLE
		{
			public Guid guidSignature;
		}
		[CRepr]
		public struct tagIMMPID_GUIDLIST_ITEM
		{
			public Guid* pguid;
			public uint32 dwStart;
			public uint32 dwLast;
		}
		
		// --- COM Class IDs ---
		
		public const Guid CLSID_MsftDiscMaster2 = .(0x2735412e, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);
		public const Guid CLSID_MsftDiscRecorder2 = .(0x2735412d, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);
		public const Guid CLSID_MsftWriteEngine2 = .(0x2735412c, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);
		public const Guid CLSID_MsftDiscFormat2Erase = .(0x2735412b, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);
		public const Guid CLSID_MsftDiscFormat2Data = .(0x2735412a, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);
		public const Guid CLSID_MsftDiscFormat2TrackAtOnce = .(0x27354129, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);
		public const Guid CLSID_MsftDiscFormat2RawCD = .(0x27354128, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);
		public const Guid CLSID_MsftStreamZero = .(0x27354127, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);
		public const Guid CLSID_MsftStreamPrng001 = .(0x27354126, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);
		public const Guid CLSID_MsftStreamConcatenate = .(0x27354125, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);
		public const Guid CLSID_MsftStreamInterleave = .(0x27354124, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);
		public const Guid CLSID_MsftWriteSpeedDescriptor = .(0x27354123, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);
		public const Guid CLSID_MsftMultisessionSequential = .(0x27354122, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);
		public const Guid CLSID_MsftMultisessionRandomWrite = .(0xb507ca24, 0x2204, 0x11dd, 0x96, 0x6a, 0x00, 0x1a, 0xa0, 0x1b, 0xbc, 0x58);
		public const Guid CLSID_MsftRawCDImageCreator = .(0x25983561, 0x9d65, 0x49ce, 0xb3, 0x35, 0x40, 0x63, 0x0d, 0x90, 0x12, 0x27);
		public const Guid CLSID_BootOptions = .(0x2c941fce, 0x975b, 0x59be, 0xa9, 0x60, 0x9a, 0x2a, 0x26, 0x28, 0x53, 0xa5);
		public const Guid CLSID_FsiStream = .(0x2c941fcd, 0x975b, 0x59be, 0xa9, 0x60, 0x9a, 0x2a, 0x26, 0x28, 0x53, 0xa5);
		public const Guid CLSID_FileSystemImageResult = .(0x2c941fcc, 0x975b, 0x59be, 0xa9, 0x60, 0x9a, 0x2a, 0x26, 0x28, 0x53, 0xa5);
		public const Guid CLSID_ProgressItem = .(0x2c941fcb, 0x975b, 0x59be, 0xa9, 0x60, 0x9a, 0x2a, 0x26, 0x28, 0x53, 0xa5);
		public const Guid CLSID_EnumProgressItems = .(0x2c941fca, 0x975b, 0x59be, 0xa9, 0x60, 0x9a, 0x2a, 0x26, 0x28, 0x53, 0xa5);
		public const Guid CLSID_ProgressItems = .(0x2c941fc9, 0x975b, 0x59be, 0xa9, 0x60, 0x9a, 0x2a, 0x26, 0x28, 0x53, 0xa5);
		public const Guid CLSID_FsiDirectoryItem = .(0x2c941fc8, 0x975b, 0x59be, 0xa9, 0x60, 0x9a, 0x2a, 0x26, 0x28, 0x53, 0xa5);
		public const Guid CLSID_FsiFileItem = .(0x2c941fc7, 0x975b, 0x59be, 0xa9, 0x60, 0x9a, 0x2a, 0x26, 0x28, 0x53, 0xa5);
		public const Guid CLSID_EnumFsiItems = .(0x2c941fc6, 0x975b, 0x59be, 0xa9, 0x60, 0x9a, 0x2a, 0x26, 0x28, 0x53, 0xa5);
		public const Guid CLSID_FsiNamedStreams = .(0xc6b6f8ed, 0x6d19, 0x44b4, 0xb5, 0x39, 0xb1, 0x59, 0xb7, 0x93, 0xa3, 0x2d);
		public const Guid CLSID_MsftFileSystemImage = .(0x2c941fc5, 0x975b, 0x59be, 0xa9, 0x60, 0x9a, 0x2a, 0x26, 0x28, 0x53, 0xa5);
		public const Guid CLSID_MsftIsoImageManager = .(0xceee3b62, 0x8f56, 0x4056, 0x86, 0x9b, 0xef, 0x16, 0x91, 0x7e, 0x3e, 0xfc);
		public const Guid CLSID_BlockRange = .(0xb507ca27, 0x2204, 0x11dd, 0x96, 0x6a, 0x00, 0x1a, 0xa0, 0x1b, 0xbc, 0x58);
		public const Guid CLSID_BlockRangeList = .(0xb507ca28, 0x2204, 0x11dd, 0x96, 0x6a, 0x00, 0x1a, 0xa0, 0x1b, 0xbc, 0x58);
		public const Guid CLSID_MSDiscRecorderObj = .(0x520cca61, 0x51a5, 0x11d3, 0x91, 0x44, 0x00, 0x10, 0x4b, 0xa1, 0x1c, 0x5e);
		public const Guid CLSID_MSDiscMasterObj = .(0x520cca63, 0x51a5, 0x11d3, 0x91, 0x44, 0x00, 0x10, 0x4b, 0xa1, 0x1c, 0x5e);
		public const Guid CLSID_MSEnumDiscRecordersObj = .(0x8a03567a, 0x63cb, 0x4ba8, 0xba, 0xf6, 0x52, 0x11, 0x98, 0x16, 0xd1, 0xef);
		public const Guid CLSID_tagIMMPID_MP_STRUCT = .(0x13384cf0, 0xb3c4, 0x11d1, 0xaa, 0x92, 0x00, 0xaa, 0x00, 0x6b, 0xc8, 0x0b);
		public const Guid CLSID_tagIMMPID_RP_STRUCT = .(0x79e82048, 0xd320, 0x11d1, 0x9f, 0xf4, 0x00, 0xc0, 0x4f, 0xa3, 0x73, 0x48);
		public const Guid CLSID_tagIMMPID_MPV_STRUCT = .(0xcbe69706, 0xc9bd, 0x11d1, 0x9f, 0xf2, 0x00, 0xc0, 0x4f, 0xa3, 0x73, 0x48);
		public const Guid CLSID_tagIMMPID_RPV_STRUCT = .(0x79e82049, 0xd320, 0x11d1, 0x9f, 0xf4, 0x00, 0xc0, 0x4f, 0xa3, 0x73, 0x48);
		public const Guid CLSID_tagIMMPID_NMP_STRUCT = .(0x7433a9aa, 0x20e2, 0x11d2, 0x94, 0xd6, 0x00, 0xc0, 0x4f, 0xa3, 0x79, 0xf1);
		public const Guid CLSID_tagIMMPID_CPV_STRUCT = .(0xa2a76b2a, 0xe52d, 0x11d1, 0xaa, 0x64, 0x00, 0xc0, 0x4f, 0xa3, 0x5b, 0x82);
		
		// --- COM Interfaces ---
		
		[CRepr]
		public struct IDiscMaster2 : IDispatch
		{
			public const new Guid IID = .(0x27354130, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IDispatch.VTable
			{
				public function HRESULT(IDiscMaster2 *self, IEnumVARIANT** ppunk) get__NewEnum;
				public function HRESULT(IDiscMaster2 *self, int32 index, BSTR* value) get_Item;
				public function HRESULT(IDiscMaster2 *self, int32* value) get_Count;
				public function HRESULT(IDiscMaster2 *self, int16* value) get_IsSupportedEnvironment;
			}
		}
		[CRepr]
		public struct DDiscMaster2Events : IDispatch
		{
			public const new Guid IID = .(0x27354131, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IDispatch.VTable
			{
				public function HRESULT(DDiscMaster2Events *self, IDispatch* object, BSTR uniqueId) NotifyDeviceAdded;
				public function HRESULT(DDiscMaster2Events *self, IDispatch* object, BSTR uniqueId) NotifyDeviceRemoved;
			}
		}
		[CRepr]
		public struct IDiscRecorder2Ex : IUnknown
		{
			public const new Guid IID = .(0x27354132, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public function HRESULT(IDiscRecorder2Ex *self, uint8* Cdb, uint32 CdbSize, uint8* SenseBuffer, uint32 Timeout) SendCommandNoData;
				public function HRESULT(IDiscRecorder2Ex *self, uint8* Cdb, uint32 CdbSize, uint8* SenseBuffer, uint32 Timeout, uint8* Buffer, uint32 BufferSize) SendCommandSendDataToDevice;
				public function HRESULT(IDiscRecorder2Ex *self, uint8* Cdb, uint32 CdbSize, uint8* SenseBuffer, uint32 Timeout, uint8* Buffer, uint32 BufferSize, uint32* BufferFetched) SendCommandGetDataFromDevice;
				public function HRESULT(IDiscRecorder2Ex *self, uint32 format, uint32 address, uint32 layer, uint32 agid, uint8** data, uint32* count) ReadDvdStructure;
				public function HRESULT(IDiscRecorder2Ex *self, uint32 format, uint8* data, uint32 count) SendDvdStructure;
				public function HRESULT(IDiscRecorder2Ex *self, uint8** data, uint32* byteSize) GetAdapterDescriptor;
				public function HRESULT(IDiscRecorder2Ex *self, uint8** data, uint32* byteSize) GetDeviceDescriptor;
				public function HRESULT(IDiscRecorder2Ex *self, uint8** discInformation, uint32* byteSize) GetDiscInformation;
				public function HRESULT(IDiscRecorder2Ex *self, uint32 address, IMAPI_READ_TRACK_ADDRESS_TYPE addressType, uint8** trackInformation, uint32* byteSize) GetTrackInformation;
				public function HRESULT(IDiscRecorder2Ex *self, IMAPI_FEATURE_PAGE_TYPE requestedFeature, BOOLEAN currentFeatureOnly, uint8** featureData, uint32* byteSize) GetFeaturePage;
				public function HRESULT(IDiscRecorder2Ex *self, IMAPI_MODE_PAGE_TYPE requestedModePage, IMAPI_MODE_PAGE_REQUEST_TYPE requestType, uint8** modePageData, uint32* byteSize) GetModePage;
				public function HRESULT(IDiscRecorder2Ex *self, IMAPI_MODE_PAGE_REQUEST_TYPE requestType, uint8* data, uint32 byteSize) SetModePage;
				public function HRESULT(IDiscRecorder2Ex *self, BOOLEAN currentFeatureOnly, IMAPI_FEATURE_PAGE_TYPE** featureData, uint32* byteSize) GetSupportedFeaturePages;
				public function HRESULT(IDiscRecorder2Ex *self, BOOLEAN currentOnly, IMAPI_PROFILE_TYPE** profileTypes, uint32* validProfiles) GetSupportedProfiles;
				public function HRESULT(IDiscRecorder2Ex *self, IMAPI_MODE_PAGE_REQUEST_TYPE requestType, IMAPI_MODE_PAGE_TYPE** modePageTypes, uint32* validPages) GetSupportedModePages;
				public function HRESULT(IDiscRecorder2Ex *self, uint32* value) GetByteAlignmentMask;
				public function HRESULT(IDiscRecorder2Ex *self, uint32* value) GetMaximumNonPageAlignedTransferSize;
				public function HRESULT(IDiscRecorder2Ex *self, uint32* value) GetMaximumPageAlignedTransferSize;
			}
		}
		[CRepr]
		public struct IDiscRecorder2 : IDispatch
		{
			public const new Guid IID = .(0x27354133, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IDispatch.VTable
			{
				public function HRESULT(IDiscRecorder2 *self) EjectMedia;
				public function HRESULT(IDiscRecorder2 *self) CloseTray;
				public function HRESULT(IDiscRecorder2 *self, int16 force, BSTR __MIDL__IDiscRecorder20000) AcquireExclusiveAccess;
				public function HRESULT(IDiscRecorder2 *self) ReleaseExclusiveAccess;
				public function HRESULT(IDiscRecorder2 *self) DisableMcn;
				public function HRESULT(IDiscRecorder2 *self) EnableMcn;
				public function HRESULT(IDiscRecorder2 *self, BSTR recorderUniqueId) InitializeDiscRecorder;
				public function HRESULT(IDiscRecorder2 *self, BSTR* value) get_ActiveDiscRecorder;
				public function HRESULT(IDiscRecorder2 *self, BSTR* value) get_VendorId;
				public function HRESULT(IDiscRecorder2 *self, BSTR* value) get_ProductId;
				public function HRESULT(IDiscRecorder2 *self, BSTR* value) get_ProductRevision;
				public function HRESULT(IDiscRecorder2 *self, BSTR* value) get_VolumeName;
				public function HRESULT(IDiscRecorder2 *self, SAFEARRAY** value) get_VolumePathNames;
				public function HRESULT(IDiscRecorder2 *self, int16* value) get_DeviceCanLoadMedia;
				public function HRESULT(IDiscRecorder2 *self, int32* legacyDeviceNumber) get_LegacyDeviceNumber;
				public function HRESULT(IDiscRecorder2 *self, SAFEARRAY** value) get_SupportedFeaturePages;
				public function HRESULT(IDiscRecorder2 *self, SAFEARRAY** value) get_CurrentFeaturePages;
				public function HRESULT(IDiscRecorder2 *self, SAFEARRAY** value) get_SupportedProfiles;
				public function HRESULT(IDiscRecorder2 *self, SAFEARRAY** value) get_CurrentProfiles;
				public function HRESULT(IDiscRecorder2 *self, SAFEARRAY** value) get_SupportedModePages;
				public function HRESULT(IDiscRecorder2 *self, BSTR* value) get_ExclusiveAccessOwner;
			}
		}
		[CRepr]
		public struct IWriteEngine2 : IDispatch
		{
			public const new Guid IID = .(0x27354135, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IDispatch.VTable
			{
				public function HRESULT(IWriteEngine2 *self, IStream* data, int32 startingBlockAddress, int32 numberOfBlocks) WriteSection;
				public function HRESULT(IWriteEngine2 *self) CancelWrite;
				public function HRESULT(IWriteEngine2 *self, IDiscRecorder2Ex* value) put_Recorder;
				public function HRESULT(IWriteEngine2 *self, IDiscRecorder2Ex** value) get_Recorder;
				public function HRESULT(IWriteEngine2 *self, int16 value) put_UseStreamingWrite12;
				public function HRESULT(IWriteEngine2 *self, int16* value) get_UseStreamingWrite12;
				public function HRESULT(IWriteEngine2 *self, int32 value) put_StartingSectorsPerSecond;
				public function HRESULT(IWriteEngine2 *self, int32* value) get_StartingSectorsPerSecond;
				public function HRESULT(IWriteEngine2 *self, int32 value) put_EndingSectorsPerSecond;
				public function HRESULT(IWriteEngine2 *self, int32* value) get_EndingSectorsPerSecond;
				public function HRESULT(IWriteEngine2 *self, int32 value) put_BytesPerSector;
				public function HRESULT(IWriteEngine2 *self, int32* value) get_BytesPerSector;
				public function HRESULT(IWriteEngine2 *self, int16* value) get_WriteInProgress;
			}
		}
		[CRepr]
		public struct IWriteEngine2EventArgs : IDispatch
		{
			public const new Guid IID = .(0x27354136, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IDispatch.VTable
			{
				public function HRESULT(IWriteEngine2EventArgs *self, int32* value) get_StartLba;
				public function HRESULT(IWriteEngine2EventArgs *self, int32* value) get_SectorCount;
				public function HRESULT(IWriteEngine2EventArgs *self, int32* value) get_LastReadLba;
				public function HRESULT(IWriteEngine2EventArgs *self, int32* value) get_LastWrittenLba;
				public function HRESULT(IWriteEngine2EventArgs *self, int32* value) get_TotalSystemBuffer;
				public function HRESULT(IWriteEngine2EventArgs *self, int32* value) get_UsedSystemBuffer;
				public function HRESULT(IWriteEngine2EventArgs *self, int32* value) get_FreeSystemBuffer;
			}
		}
		[CRepr]
		public struct DWriteEngine2Events : IDispatch
		{
			public const new Guid IID = .(0x27354137, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IDispatch.VTable
			{
				public function HRESULT(DWriteEngine2Events *self, IDispatch* object, IDispatch* progress) Update;
			}
		}
		[CRepr]
		public struct IDiscFormat2 : IDispatch
		{
			public const new Guid IID = .(0x27354152, 0x8f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IDispatch.VTable
			{
				public function HRESULT(IDiscFormat2 *self, IDiscRecorder2* recorder, int16* value) IsRecorderSupported;
				public function HRESULT(IDiscFormat2 *self, IDiscRecorder2* recorder, int16* value) IsCurrentMediaSupported;
				public function HRESULT(IDiscFormat2 *self, int16* value) get_MediaPhysicallyBlank;
				public function HRESULT(IDiscFormat2 *self, int16* value) get_MediaHeuristicallyBlank;
				public function HRESULT(IDiscFormat2 *self, SAFEARRAY** value) get_SupportedMediaTypes;
			}
		}
		[CRepr]
		public struct IDiscFormat2Erase : IDiscFormat2
		{
			public const new Guid IID = .(0x27354156, 0x8f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IDiscFormat2.VTable
			{
				public function HRESULT(IDiscFormat2Erase *self, IDiscRecorder2* value) put_Recorder;
				public function HRESULT(IDiscFormat2Erase *self, IDiscRecorder2** value) get_Recorder;
				public function HRESULT(IDiscFormat2Erase *self, int16 value) put_FullErase;
				public function HRESULT(IDiscFormat2Erase *self, int16* value) get_FullErase;
				public function HRESULT(IDiscFormat2Erase *self, IMAPI_MEDIA_PHYSICAL_TYPE* value) get_CurrentPhysicalMediaType;
				public function HRESULT(IDiscFormat2Erase *self, BSTR value) put_ClientName;
				public function HRESULT(IDiscFormat2Erase *self, BSTR* value) get_ClientName;
				public function HRESULT(IDiscFormat2Erase *self) EraseMedia;
			}
		}
		[CRepr]
		public struct DDiscFormat2EraseEvents : IDispatch
		{
			public const new Guid IID = .(0x2735413a, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IDispatch.VTable
			{
				public function HRESULT(DDiscFormat2EraseEvents *self, IDispatch* object, int32 elapsedSeconds, int32 estimatedTotalSeconds) Update;
			}
		}
		[CRepr]
		public struct IDiscFormat2Data : IDiscFormat2
		{
			public const new Guid IID = .(0x27354153, 0x9f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IDiscFormat2.VTable
			{
				public function HRESULT(IDiscFormat2Data *self, IDiscRecorder2* value) put_Recorder;
				public function HRESULT(IDiscFormat2Data *self, IDiscRecorder2** value) get_Recorder;
				public function HRESULT(IDiscFormat2Data *self, int16 value) put_BufferUnderrunFreeDisabled;
				public function HRESULT(IDiscFormat2Data *self, int16* value) get_BufferUnderrunFreeDisabled;
				public function HRESULT(IDiscFormat2Data *self, int16 value) put_PostgapAlreadyInImage;
				public function HRESULT(IDiscFormat2Data *self, int16* value) get_PostgapAlreadyInImage;
				public function HRESULT(IDiscFormat2Data *self, IMAPI_FORMAT2_DATA_MEDIA_STATE* value) get_CurrentMediaStatus;
				public function HRESULT(IDiscFormat2Data *self, IMAPI_MEDIA_WRITE_PROTECT_STATE* value) get_WriteProtectStatus;
				public function HRESULT(IDiscFormat2Data *self, int32* value) get_TotalSectorsOnMedia;
				public function HRESULT(IDiscFormat2Data *self, int32* value) get_FreeSectorsOnMedia;
				public function HRESULT(IDiscFormat2Data *self, int32* value) get_NextWritableAddress;
				public function HRESULT(IDiscFormat2Data *self, int32* value) get_StartAddressOfPreviousSession;
				public function HRESULT(IDiscFormat2Data *self, int32* value) get_LastWrittenAddressOfPreviousSession;
				public function HRESULT(IDiscFormat2Data *self, int16 value) put_ForceMediaToBeClosed;
				public function HRESULT(IDiscFormat2Data *self, int16* value) get_ForceMediaToBeClosed;
				public function HRESULT(IDiscFormat2Data *self, int16 value) put_DisableConsumerDvdCompatibilityMode;
				public function HRESULT(IDiscFormat2Data *self, int16* value) get_DisableConsumerDvdCompatibilityMode;
				public function HRESULT(IDiscFormat2Data *self, IMAPI_MEDIA_PHYSICAL_TYPE* value) get_CurrentPhysicalMediaType;
				public function HRESULT(IDiscFormat2Data *self, BSTR value) put_ClientName;
				public function HRESULT(IDiscFormat2Data *self, BSTR* value) get_ClientName;
				public function HRESULT(IDiscFormat2Data *self, int32* value) get_RequestedWriteSpeed;
				public function HRESULT(IDiscFormat2Data *self, int16* value) get_RequestedRotationTypeIsPureCAV;
				public function HRESULT(IDiscFormat2Data *self, int32* value) get_CurrentWriteSpeed;
				public function HRESULT(IDiscFormat2Data *self, int16* value) get_CurrentRotationTypeIsPureCAV;
				public function HRESULT(IDiscFormat2Data *self, SAFEARRAY** supportedSpeeds) get_SupportedWriteSpeeds;
				public function HRESULT(IDiscFormat2Data *self, SAFEARRAY** supportedSpeedDescriptors) get_SupportedWriteSpeedDescriptors;
				public function HRESULT(IDiscFormat2Data *self, int16 value) put_ForceOverwrite;
				public function HRESULT(IDiscFormat2Data *self, int16* value) get_ForceOverwrite;
				public function HRESULT(IDiscFormat2Data *self, SAFEARRAY** value) get_MultisessionInterfaces;
				public function HRESULT(IDiscFormat2Data *self, IStream* data) Write;
				public function HRESULT(IDiscFormat2Data *self) CancelWrite;
				public function HRESULT(IDiscFormat2Data *self, int32 RequestedSectorsPerSecond, int16 RotationTypeIsPureCAV) SetWriteSpeed;
			}
		}
		[CRepr]
		public struct DDiscFormat2DataEvents : IDispatch
		{
			public const new Guid IID = .(0x2735413c, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IDispatch.VTable
			{
				public function HRESULT(DDiscFormat2DataEvents *self, IDispatch* object, IDispatch* progress) Update;
			}
		}
		[CRepr]
		public struct IDiscFormat2DataEventArgs : IWriteEngine2EventArgs
		{
			public const new Guid IID = .(0x2735413d, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IWriteEngine2EventArgs.VTable
			{
				public function HRESULT(IDiscFormat2DataEventArgs *self, int32* value) get_ElapsedTime;
				public function HRESULT(IDiscFormat2DataEventArgs *self, int32* value) get_RemainingTime;
				public function HRESULT(IDiscFormat2DataEventArgs *self, int32* value) get_TotalTime;
				public function HRESULT(IDiscFormat2DataEventArgs *self, IMAPI_FORMAT2_DATA_WRITE_ACTION* value) get_CurrentAction;
			}
		}
		[CRepr]
		public struct IDiscFormat2TrackAtOnce : IDiscFormat2
		{
			public const new Guid IID = .(0x27354154, 0x8f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IDiscFormat2.VTable
			{
				public function HRESULT(IDiscFormat2TrackAtOnce *self) PrepareMedia;
				public function HRESULT(IDiscFormat2TrackAtOnce *self, IStream* data) AddAudioTrack;
				public function HRESULT(IDiscFormat2TrackAtOnce *self) CancelAddTrack;
				public function HRESULT(IDiscFormat2TrackAtOnce *self) ReleaseMedia;
				public function HRESULT(IDiscFormat2TrackAtOnce *self, int32 RequestedSectorsPerSecond, int16 RotationTypeIsPureCAV) SetWriteSpeed;
				public function HRESULT(IDiscFormat2TrackAtOnce *self, IDiscRecorder2* value) put_Recorder;
				public function HRESULT(IDiscFormat2TrackAtOnce *self, IDiscRecorder2** value) get_Recorder;
				public function HRESULT(IDiscFormat2TrackAtOnce *self, int16 value) put_BufferUnderrunFreeDisabled;
				public function HRESULT(IDiscFormat2TrackAtOnce *self, int16* value) get_BufferUnderrunFreeDisabled;
				public function HRESULT(IDiscFormat2TrackAtOnce *self, int32* value) get_NumberOfExistingTracks;
				public function HRESULT(IDiscFormat2TrackAtOnce *self, int32* value) get_TotalSectorsOnMedia;
				public function HRESULT(IDiscFormat2TrackAtOnce *self, int32* value) get_FreeSectorsOnMedia;
				public function HRESULT(IDiscFormat2TrackAtOnce *self, int32* value) get_UsedSectorsOnMedia;
				public function HRESULT(IDiscFormat2TrackAtOnce *self, int16 value) put_DoNotFinalizeMedia;
				public function HRESULT(IDiscFormat2TrackAtOnce *self, int16* value) get_DoNotFinalizeMedia;
				public function HRESULT(IDiscFormat2TrackAtOnce *self, SAFEARRAY** value) get_ExpectedTableOfContents;
				public function HRESULT(IDiscFormat2TrackAtOnce *self, IMAPI_MEDIA_PHYSICAL_TYPE* value) get_CurrentPhysicalMediaType;
				public function HRESULT(IDiscFormat2TrackAtOnce *self, BSTR value) put_ClientName;
				public function HRESULT(IDiscFormat2TrackAtOnce *self, BSTR* value) get_ClientName;
				public function HRESULT(IDiscFormat2TrackAtOnce *self, int32* value) get_RequestedWriteSpeed;
				public function HRESULT(IDiscFormat2TrackAtOnce *self, int16* value) get_RequestedRotationTypeIsPureCAV;
				public function HRESULT(IDiscFormat2TrackAtOnce *self, int32* value) get_CurrentWriteSpeed;
				public function HRESULT(IDiscFormat2TrackAtOnce *self, int16* value) get_CurrentRotationTypeIsPureCAV;
				public function HRESULT(IDiscFormat2TrackAtOnce *self, SAFEARRAY** supportedSpeeds) get_SupportedWriteSpeeds;
				public function HRESULT(IDiscFormat2TrackAtOnce *self, SAFEARRAY** supportedSpeedDescriptors) get_SupportedWriteSpeedDescriptors;
			}
		}
		[CRepr]
		public struct DDiscFormat2TrackAtOnceEvents : IDispatch
		{
			public const new Guid IID = .(0x2735413f, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IDispatch.VTable
			{
				public function HRESULT(DDiscFormat2TrackAtOnceEvents *self, IDispatch* object, IDispatch* progress) Update;
			}
		}
		[CRepr]
		public struct IDiscFormat2TrackAtOnceEventArgs : IWriteEngine2EventArgs
		{
			public const new Guid IID = .(0x27354140, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IWriteEngine2EventArgs.VTable
			{
				public function HRESULT(IDiscFormat2TrackAtOnceEventArgs *self, int32* value) get_CurrentTrackNumber;
				public function HRESULT(IDiscFormat2TrackAtOnceEventArgs *self, IMAPI_FORMAT2_TAO_WRITE_ACTION* value) get_CurrentAction;
				public function HRESULT(IDiscFormat2TrackAtOnceEventArgs *self, int32* value) get_ElapsedTime;
				public function HRESULT(IDiscFormat2TrackAtOnceEventArgs *self, int32* value) get_RemainingTime;
			}
		}
		[CRepr]
		public struct IDiscFormat2RawCD : IDiscFormat2
		{
			public const new Guid IID = .(0x27354155, 0x8f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IDiscFormat2.VTable
			{
				public function HRESULT(IDiscFormat2RawCD *self) PrepareMedia;
				public function HRESULT(IDiscFormat2RawCD *self, IStream* data) WriteMedia;
				public function HRESULT(IDiscFormat2RawCD *self, IStream* data, int32 streamLeadInSectors) WriteMedia2;
				public function HRESULT(IDiscFormat2RawCD *self) CancelWrite;
				public function HRESULT(IDiscFormat2RawCD *self) ReleaseMedia;
				public function HRESULT(IDiscFormat2RawCD *self, int32 RequestedSectorsPerSecond, int16 RotationTypeIsPureCAV) SetWriteSpeed;
				public function HRESULT(IDiscFormat2RawCD *self, IDiscRecorder2* value) put_Recorder;
				public function HRESULT(IDiscFormat2RawCD *self, IDiscRecorder2** value) get_Recorder;
				public function HRESULT(IDiscFormat2RawCD *self, int16 value) put_BufferUnderrunFreeDisabled;
				public function HRESULT(IDiscFormat2RawCD *self, int16* value) get_BufferUnderrunFreeDisabled;
				public function HRESULT(IDiscFormat2RawCD *self, int32* value) get_StartOfNextSession;
				public function HRESULT(IDiscFormat2RawCD *self, int32* value) get_LastPossibleStartOfLeadout;
				public function HRESULT(IDiscFormat2RawCD *self, IMAPI_MEDIA_PHYSICAL_TYPE* value) get_CurrentPhysicalMediaType;
				public function HRESULT(IDiscFormat2RawCD *self, SAFEARRAY** value) get_SupportedSectorTypes;
				public function HRESULT(IDiscFormat2RawCD *self, IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE value) put_RequestedSectorType;
				public function HRESULT(IDiscFormat2RawCD *self, IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE* value) get_RequestedSectorType;
				public function HRESULT(IDiscFormat2RawCD *self, BSTR value) put_ClientName;
				public function HRESULT(IDiscFormat2RawCD *self, BSTR* value) get_ClientName;
				public function HRESULT(IDiscFormat2RawCD *self, int32* value) get_RequestedWriteSpeed;
				public function HRESULT(IDiscFormat2RawCD *self, int16* value) get_RequestedRotationTypeIsPureCAV;
				public function HRESULT(IDiscFormat2RawCD *self, int32* value) get_CurrentWriteSpeed;
				public function HRESULT(IDiscFormat2RawCD *self, int16* value) get_CurrentRotationTypeIsPureCAV;
				public function HRESULT(IDiscFormat2RawCD *self, SAFEARRAY** supportedSpeeds) get_SupportedWriteSpeeds;
				public function HRESULT(IDiscFormat2RawCD *self, SAFEARRAY** supportedSpeedDescriptors) get_SupportedWriteSpeedDescriptors;
			}
		}
		[CRepr]
		public struct DDiscFormat2RawCDEvents : IDispatch
		{
			public const new Guid IID = .(0x27354142, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IDispatch.VTable
			{
				public function HRESULT(DDiscFormat2RawCDEvents *self, IDispatch* object, IDispatch* progress) Update;
			}
		}
		[CRepr]
		public struct IDiscFormat2RawCDEventArgs : IWriteEngine2EventArgs
		{
			public const new Guid IID = .(0x27354143, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IWriteEngine2EventArgs.VTable
			{
				public function HRESULT(IDiscFormat2RawCDEventArgs *self, IMAPI_FORMAT2_RAW_CD_WRITE_ACTION* value) get_CurrentAction;
				public function HRESULT(IDiscFormat2RawCDEventArgs *self, int32* value) get_ElapsedTime;
				public function HRESULT(IDiscFormat2RawCDEventArgs *self, int32* value) get_RemainingTime;
			}
		}
		[CRepr]
		public struct IBurnVerification : IUnknown
		{
			public const new Guid IID = .(0xd2ffd834, 0x958b, 0x426d, 0x84, 0x70, 0x2a, 0x13, 0x87, 0x9c, 0x6a, 0x91);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public function HRESULT(IBurnVerification *self, IMAPI_BURN_VERIFICATION_LEVEL value) put_BurnVerificationLevel;
				public function HRESULT(IBurnVerification *self, IMAPI_BURN_VERIFICATION_LEVEL* value) get_BurnVerificationLevel;
			}
		}
		[CRepr]
		public struct IWriteSpeedDescriptor : IDispatch
		{
			public const new Guid IID = .(0x27354144, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IDispatch.VTable
			{
				public function HRESULT(IWriteSpeedDescriptor *self, IMAPI_MEDIA_PHYSICAL_TYPE* value) get_MediaType;
				public function HRESULT(IWriteSpeedDescriptor *self, int16* value) get_RotationTypeIsPureCAV;
				public function HRESULT(IWriteSpeedDescriptor *self, int32* value) get_WriteSpeed;
			}
		}
		[CRepr]
		public struct IMultisession : IDispatch
		{
			public const new Guid IID = .(0x27354150, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IDispatch.VTable
			{
				public function HRESULT(IMultisession *self, int16* value) get_IsSupportedOnCurrentMediaState;
				public function HRESULT(IMultisession *self, int16 value) put_InUse;
				public function HRESULT(IMultisession *self, int16* value) get_InUse;
				public function HRESULT(IMultisession *self, IDiscRecorder2** value) get_ImportRecorder;
			}
		}
		[CRepr]
		public struct IMultisessionSequential : IMultisession
		{
			public const new Guid IID = .(0x27354151, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IMultisession.VTable
			{
				public function HRESULT(IMultisessionSequential *self, int16* value) get_IsFirstDataSession;
				public function HRESULT(IMultisessionSequential *self, int32* value) get_StartAddressOfPreviousSession;
				public function HRESULT(IMultisessionSequential *self, int32* value) get_LastWrittenAddressOfPreviousSession;
				public function HRESULT(IMultisessionSequential *self, int32* value) get_NextWritableAddress;
				public function HRESULT(IMultisessionSequential *self, int32* value) get_FreeSectorsOnMedia;
			}
		}
		[CRepr]
		public struct IMultisessionSequential2 : IMultisessionSequential
		{
			public const new Guid IID = .(0xb507ca22, 0x2204, 0x11dd, 0x96, 0x6a, 0x00, 0x1a, 0xa0, 0x1b, 0xbc, 0x58);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IMultisessionSequential.VTable
			{
				public function HRESULT(IMultisessionSequential2 *self, int32* value) get_WriteUnitSize;
			}
		}
		[CRepr]
		public struct IMultisessionRandomWrite : IMultisession
		{
			public const new Guid IID = .(0xb507ca23, 0x2204, 0x11dd, 0x96, 0x6a, 0x00, 0x1a, 0xa0, 0x1b, 0xbc, 0x58);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IMultisession.VTable
			{
				public function HRESULT(IMultisessionRandomWrite *self, int32* value) get_WriteUnitSize;
				public function HRESULT(IMultisessionRandomWrite *self, int32* value) get_LastWrittenAddress;
				public function HRESULT(IMultisessionRandomWrite *self, int32* value) get_TotalSectorsOnMedia;
			}
		}
		[CRepr]
		public struct IStreamPseudoRandomBased : IStream
		{
			public const new Guid IID = .(0x27354145, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IStream.VTable
			{
				public function HRESULT(IStreamPseudoRandomBased *self, uint32 value) put_Seed;
				public function HRESULT(IStreamPseudoRandomBased *self, uint32* value) get_Seed;
				public function HRESULT(IStreamPseudoRandomBased *self, uint32* values, uint32 eCount) put_ExtendedSeed;
				public function HRESULT(IStreamPseudoRandomBased *self, uint32** values, uint32* eCount) get_ExtendedSeed;
			}
		}
		[CRepr]
		public struct IStreamConcatenate : IStream
		{
			public const new Guid IID = .(0x27354146, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IStream.VTable
			{
				public function HRESULT(IStreamConcatenate *self, IStream* stream1, IStream* stream2) Initialize;
				public function HRESULT(IStreamConcatenate *self, IStream** streams, uint32 streamCount) Initialize2;
				public function HRESULT(IStreamConcatenate *self, IStream* stream) Append;
				public function HRESULT(IStreamConcatenate *self, IStream** streams, uint32 streamCount) Append2;
			}
		}
		[CRepr]
		public struct IStreamInterleave : IStream
		{
			public const new Guid IID = .(0x27354147, 0x7f64, 0x5b0f, 0x8f, 0x00, 0x5d, 0x77, 0xaf, 0xbe, 0x26, 0x1e);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IStream.VTable
			{
				public function HRESULT(IStreamInterleave *self, IStream** streams, uint32* interleaveSizes, uint32 streamCount) Initialize;
			}
		}
		[CRepr]
		public struct IRawCDImageCreator : IDispatch
		{
			public const new Guid IID = .(0x25983550, 0x9d65, 0x49ce, 0xb3, 0x35, 0x40, 0x63, 0x0d, 0x90, 0x12, 0x27);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IDispatch.VTable
			{
				public function HRESULT(IRawCDImageCreator *self, IStream** resultStream) CreateResultImage;
				public function HRESULT(IRawCDImageCreator *self, IMAPI_CD_SECTOR_TYPE dataType, IStream* data, int32* trackIndex) AddTrack;
				public function HRESULT(IRawCDImageCreator *self, IStream* data) AddSpecialPregap;
				public function HRESULT(IRawCDImageCreator *self, IStream* subcode) AddSubcodeRWGenerator;
				public function HRESULT(IRawCDImageCreator *self, IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE value) put_ResultingImageType;
				public function HRESULT(IRawCDImageCreator *self, IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE* value) get_ResultingImageType;
				public function HRESULT(IRawCDImageCreator *self, int32* value) get_StartOfLeadout;
				public function HRESULT(IRawCDImageCreator *self, int32 value) put_StartOfLeadoutLimit;
				public function HRESULT(IRawCDImageCreator *self, int32* value) get_StartOfLeadoutLimit;
				public function HRESULT(IRawCDImageCreator *self, int16 value) put_DisableGaplessAudio;
				public function HRESULT(IRawCDImageCreator *self, int16* value) get_DisableGaplessAudio;
				public function HRESULT(IRawCDImageCreator *self, BSTR value) put_MediaCatalogNumber;
				public function HRESULT(IRawCDImageCreator *self, BSTR* value) get_MediaCatalogNumber;
				public function HRESULT(IRawCDImageCreator *self, int32 value) put_StartingTrackNumber;
				public function HRESULT(IRawCDImageCreator *self, int32* value) get_StartingTrackNumber;
				public function HRESULT(IRawCDImageCreator *self, int32 trackIndex, IRawCDImageTrackInfo** value) get_TrackInfo;
				public function HRESULT(IRawCDImageCreator *self, int32* value) get_NumberOfExistingTracks;
				public function HRESULT(IRawCDImageCreator *self, int32* value) get_LastUsedUserSectorInImage;
				public function HRESULT(IRawCDImageCreator *self, SAFEARRAY** value) get_ExpectedTableOfContents;
			}
		}
		[CRepr]
		public struct IRawCDImageTrackInfo : IDispatch
		{
			public const new Guid IID = .(0x25983551, 0x9d65, 0x49ce, 0xb3, 0x35, 0x40, 0x63, 0x0d, 0x90, 0x12, 0x27);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IDispatch.VTable
			{
				public function HRESULT(IRawCDImageTrackInfo *self, int32* value) get_StartingLba;
				public function HRESULT(IRawCDImageTrackInfo *self, int32* value) get_SectorCount;
				public function HRESULT(IRawCDImageTrackInfo *self, int32* value) get_TrackNumber;
				public function HRESULT(IRawCDImageTrackInfo *self, IMAPI_CD_SECTOR_TYPE* value) get_SectorType;
				public function HRESULT(IRawCDImageTrackInfo *self, BSTR* value) get_ISRC;
				public function HRESULT(IRawCDImageTrackInfo *self, BSTR value) put_ISRC;
				public function HRESULT(IRawCDImageTrackInfo *self, IMAPI_CD_TRACK_DIGITAL_COPY_SETTING* value) get_DigitalAudioCopySetting;
				public function HRESULT(IRawCDImageTrackInfo *self, IMAPI_CD_TRACK_DIGITAL_COPY_SETTING value) put_DigitalAudioCopySetting;
				public function HRESULT(IRawCDImageTrackInfo *self, int16* value) get_AudioHasPreemphasis;
				public function HRESULT(IRawCDImageTrackInfo *self, int16 value) put_AudioHasPreemphasis;
				public function HRESULT(IRawCDImageTrackInfo *self, SAFEARRAY** value) get_TrackIndexes;
				public function HRESULT(IRawCDImageTrackInfo *self, int32 lbaOffset) AddTrackIndex;
				public function HRESULT(IRawCDImageTrackInfo *self, int32 lbaOffset) ClearTrackIndex;
			}
		}
		[CRepr]
		public struct IBlockRange : IDispatch
		{
			public const new Guid IID = .(0xb507ca25, 0x2204, 0x11dd, 0x96, 0x6a, 0x00, 0x1a, 0xa0, 0x1b, 0xbc, 0x58);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IDispatch.VTable
			{
				public function HRESULT(IBlockRange *self, int32* value) get_StartLba;
				public function HRESULT(IBlockRange *self, int32* value) get_EndLba;
			}
		}
		[CRepr]
		public struct IBlockRangeList : IDispatch
		{
			public const new Guid IID = .(0xb507ca26, 0x2204, 0x11dd, 0x96, 0x6a, 0x00, 0x1a, 0xa0, 0x1b, 0xbc, 0x58);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IDispatch.VTable
			{
				public function HRESULT(IBlockRangeList *self, SAFEARRAY** value) get_BlockRanges;
			}
		}
		[CRepr]
		public struct IBootOptions : IDispatch
		{
			public const new Guid IID = .(0x2c941fd4, 0x975b, 0x59be, 0xa9, 0x60, 0x9a, 0x2a, 0x26, 0x28, 0x53, 0xa5);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IDispatch.VTable
			{
				public function HRESULT(IBootOptions *self, IStream** pVal) get_BootImage;
				public function HRESULT(IBootOptions *self, BSTR* pVal) get_Manufacturer;
				public function HRESULT(IBootOptions *self, BSTR newVal) put_Manufacturer;
				public function HRESULT(IBootOptions *self, PlatformId* pVal) get_PlatformId;
				public function HRESULT(IBootOptions *self, PlatformId newVal) put_PlatformId;
				public function HRESULT(IBootOptions *self, EmulationType* pVal) get_Emulation;
				public function HRESULT(IBootOptions *self, EmulationType newVal) put_Emulation;
				public function HRESULT(IBootOptions *self, uint32* pVal) get_ImageSize;
				public function HRESULT(IBootOptions *self, IStream* newVal) AssignBootImage;
			}
		}
		[CRepr]
		public struct IProgressItem : IDispatch
		{
			public const new Guid IID = .(0x2c941fd5, 0x975b, 0x59be, 0xa9, 0x60, 0x9a, 0x2a, 0x26, 0x28, 0x53, 0xa5);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IDispatch.VTable
			{
				public function HRESULT(IProgressItem *self, BSTR* desc) get_Description;
				public function HRESULT(IProgressItem *self, uint32* block) get_FirstBlock;
				public function HRESULT(IProgressItem *self, uint32* block) get_LastBlock;
				public function HRESULT(IProgressItem *self, uint32* blocks) get_BlockCount;
			}
		}
		[CRepr]
		public struct IEnumProgressItems : IUnknown
		{
			public const new Guid IID = .(0x2c941fd6, 0x975b, 0x59be, 0xa9, 0x60, 0x9a, 0x2a, 0x26, 0x28, 0x53, 0xa5);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public function HRESULT(IEnumProgressItems *self, uint32 celt, IProgressItem** rgelt, uint32* pceltFetched) Next;
				public function HRESULT(IEnumProgressItems *self, uint32 celt) Skip;
				public function HRESULT(IEnumProgressItems *self) Reset;
				public function HRESULT(IEnumProgressItems *self, IEnumProgressItems** ppEnum) Clone;
			}
		}
		[CRepr]
		public struct IProgressItems : IDispatch
		{
			public const new Guid IID = .(0x2c941fd7, 0x975b, 0x59be, 0xa9, 0x60, 0x9a, 0x2a, 0x26, 0x28, 0x53, 0xa5);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IDispatch.VTable
			{
				public function HRESULT(IProgressItems *self, IEnumVARIANT** NewEnum) get__NewEnum;
				public function HRESULT(IProgressItems *self, int32 Index, IProgressItem** item) get_Item;
				public function HRESULT(IProgressItems *self, int32* Count) get_Count;
				public function HRESULT(IProgressItems *self, uint32 block, IProgressItem** item) ProgressItemFromBlock;
				public function HRESULT(IProgressItems *self, BSTR description, IProgressItem** item) ProgressItemFromDescription;
				public function HRESULT(IProgressItems *self, IEnumProgressItems** NewEnum) get_EnumProgressItems;
			}
		}
		[CRepr]
		public struct IFileSystemImageResult : IDispatch
		{
			public const new Guid IID = .(0x2c941fd8, 0x975b, 0x59be, 0xa9, 0x60, 0x9a, 0x2a, 0x26, 0x28, 0x53, 0xa5);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IDispatch.VTable
			{
				public function HRESULT(IFileSystemImageResult *self, IStream** pVal) get_ImageStream;
				public function HRESULT(IFileSystemImageResult *self, IProgressItems** pVal) get_ProgressItems;
				public function HRESULT(IFileSystemImageResult *self, int32* pVal) get_TotalBlocks;
				public function HRESULT(IFileSystemImageResult *self, int32* pVal) get_BlockSize;
				public function HRESULT(IFileSystemImageResult *self, BSTR* pVal) get_DiscId;
			}
		}
		[CRepr]
		public struct IFileSystemImageResult2 : IFileSystemImageResult
		{
			public const new Guid IID = .(0xb507ca29, 0x2204, 0x11dd, 0x96, 0x6a, 0x00, 0x1a, 0xa0, 0x1b, 0xbc, 0x58);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IFileSystemImageResult.VTable
			{
				public function HRESULT(IFileSystemImageResult2 *self, IBlockRangeList** pVal) get_ModifiedBlocks;
			}
		}
		[CRepr]
		public struct IFsiItem : IDispatch
		{
			public const new Guid IID = .(0x2c941fd9, 0x975b, 0x59be, 0xa9, 0x60, 0x9a, 0x2a, 0x26, 0x28, 0x53, 0xa5);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IDispatch.VTable
			{
				public function HRESULT(IFsiItem *self, BSTR* pVal) get_Name;
				public function HRESULT(IFsiItem *self, BSTR* pVal) get_FullPath;
				public function HRESULT(IFsiItem *self, double* pVal) get_CreationTime;
				public function HRESULT(IFsiItem *self, double newVal) put_CreationTime;
				public function HRESULT(IFsiItem *self, double* pVal) get_LastAccessedTime;
				public function HRESULT(IFsiItem *self, double newVal) put_LastAccessedTime;
				public function HRESULT(IFsiItem *self, double* pVal) get_LastModifiedTime;
				public function HRESULT(IFsiItem *self, double newVal) put_LastModifiedTime;
				public function HRESULT(IFsiItem *self, int16* pVal) get_IsHidden;
				public function HRESULT(IFsiItem *self, int16 newVal) put_IsHidden;
				public function HRESULT(IFsiItem *self, FsiFileSystems fileSystem, BSTR* pVal) FileSystemName;
				public function HRESULT(IFsiItem *self, FsiFileSystems fileSystem, BSTR* pVal) FileSystemPath;
			}
		}
		[CRepr]
		public struct IEnumFsiItems : IUnknown
		{
			public const new Guid IID = .(0x2c941fda, 0x975b, 0x59be, 0xa9, 0x60, 0x9a, 0x2a, 0x26, 0x28, 0x53, 0xa5);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public function HRESULT(IEnumFsiItems *self, uint32 celt, IFsiItem** rgelt, uint32* pceltFetched) Next;
				public function HRESULT(IEnumFsiItems *self, uint32 celt) Skip;
				public function HRESULT(IEnumFsiItems *self) Reset;
				public function HRESULT(IEnumFsiItems *self, IEnumFsiItems** ppEnum) Clone;
			}
		}
		[CRepr]
		public struct IFsiFileItem : IFsiItem
		{
			public const new Guid IID = .(0x2c941fdb, 0x975b, 0x59be, 0xa9, 0x60, 0x9a, 0x2a, 0x26, 0x28, 0x53, 0xa5);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IFsiItem.VTable
			{
				public function HRESULT(IFsiFileItem *self, int64* pVal) get_DataSize;
				public function HRESULT(IFsiFileItem *self, int32* pVal) get_DataSize32BitLow;
				public function HRESULT(IFsiFileItem *self, int32* pVal) get_DataSize32BitHigh;
				public function HRESULT(IFsiFileItem *self, IStream** pVal) get_Data;
				public function HRESULT(IFsiFileItem *self, IStream* newVal) put_Data;
			}
		}
		[CRepr]
		public struct IFsiFileItem2 : IFsiFileItem
		{
			public const new Guid IID = .(0x199d0c19, 0x11e1, 0x40eb, 0x8e, 0xc2, 0xc8, 0xc8, 0x22, 0xa0, 0x77, 0x92);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IFsiFileItem.VTable
			{
				public function HRESULT(IFsiFileItem2 *self, IFsiNamedStreams** streams) get_FsiNamedStreams;
				public function HRESULT(IFsiFileItem2 *self, int16* pVal) get_IsNamedStream;
				public function HRESULT(IFsiFileItem2 *self, BSTR name, IStream* streamData) AddStream;
				public function HRESULT(IFsiFileItem2 *self, BSTR name) RemoveStream;
				public function HRESULT(IFsiFileItem2 *self, int16* pVal) get_IsRealTime;
				public function HRESULT(IFsiFileItem2 *self, int16 newVal) put_IsRealTime;
			}
		}
		[CRepr]
		public struct IFsiNamedStreams : IDispatch
		{
			public const new Guid IID = .(0xed79ba56, 0x5294, 0x4250, 0x8d, 0x46, 0xf9, 0xae, 0xce, 0xe2, 0x34, 0x59);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IDispatch.VTable
			{
				public function HRESULT(IFsiNamedStreams *self, IEnumVARIANT** NewEnum) get__NewEnum;
				public function HRESULT(IFsiNamedStreams *self, int32 index, IFsiFileItem2** item) get_Item;
				public function HRESULT(IFsiNamedStreams *self, int32* count) get_Count;
				public function HRESULT(IFsiNamedStreams *self, IEnumFsiItems** NewEnum) get_EnumNamedStreams;
			}
		}
		[CRepr]
		public struct IFsiDirectoryItem : IFsiItem
		{
			public const new Guid IID = .(0x2c941fdc, 0x975b, 0x59be, 0xa9, 0x60, 0x9a, 0x2a, 0x26, 0x28, 0x53, 0xa5);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IFsiItem.VTable
			{
				public function HRESULT(IFsiDirectoryItem *self, IEnumVARIANT** NewEnum) get__NewEnum;
				public function HRESULT(IFsiDirectoryItem *self, BSTR path, IFsiItem** item) get_Item;
				public function HRESULT(IFsiDirectoryItem *self, int32* Count) get_Count;
				public function HRESULT(IFsiDirectoryItem *self, IEnumFsiItems** NewEnum) get_EnumFsiItems;
				public function HRESULT(IFsiDirectoryItem *self, BSTR path) AddDirectory;
				public function HRESULT(IFsiDirectoryItem *self, BSTR path, IStream* fileData) AddFile;
				public function HRESULT(IFsiDirectoryItem *self, BSTR sourceDirectory, int16 includeBaseDirectory) AddTree;
				public function HRESULT(IFsiDirectoryItem *self, IFsiItem* item) Add;
				public function HRESULT(IFsiDirectoryItem *self, BSTR path) Remove;
				public function HRESULT(IFsiDirectoryItem *self, BSTR path) RemoveTree;
			}
		}
		[CRepr]
		public struct IFsiDirectoryItem2 : IFsiDirectoryItem
		{
			public const new Guid IID = .(0xf7fb4b9b, 0x6d96, 0x4d7b, 0x91, 0x15, 0x20, 0x1b, 0x14, 0x48, 0x11, 0xef);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IFsiDirectoryItem.VTable
			{
				public function HRESULT(IFsiDirectoryItem2 *self, BSTR sourceDirectory, int16 includeBaseDirectory) AddTreeWithNamedStreams;
			}
		}
		[CRepr]
		public struct IFileSystemImage : IDispatch
		{
			public const new Guid IID = .(0x2c941fe1, 0x975b, 0x59be, 0xa9, 0x60, 0x9a, 0x2a, 0x26, 0x28, 0x53, 0xa5);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IDispatch.VTable
			{
				public function HRESULT(IFileSystemImage *self, IFsiDirectoryItem** pVal) get_Root;
				public function HRESULT(IFileSystemImage *self, int32* pVal) get_SessionStartBlock;
				public function HRESULT(IFileSystemImage *self, int32 newVal) put_SessionStartBlock;
				public function HRESULT(IFileSystemImage *self, int32* pVal) get_FreeMediaBlocks;
				public function HRESULT(IFileSystemImage *self, int32 newVal) put_FreeMediaBlocks;
				public function HRESULT(IFileSystemImage *self, IDiscRecorder2* discRecorder) SetMaxMediaBlocksFromDevice;
				public function HRESULT(IFileSystemImage *self, int32* pVal) get_UsedBlocks;
				public function HRESULT(IFileSystemImage *self, BSTR* pVal) get_VolumeName;
				public function HRESULT(IFileSystemImage *self, BSTR newVal) put_VolumeName;
				public function HRESULT(IFileSystemImage *self, BSTR* pVal) get_ImportedVolumeName;
				public function HRESULT(IFileSystemImage *self, IBootOptions** pVal) get_BootImageOptions;
				public function HRESULT(IFileSystemImage *self, IBootOptions* newVal) put_BootImageOptions;
				public function HRESULT(IFileSystemImage *self, int32* pVal) get_FileCount;
				public function HRESULT(IFileSystemImage *self, int32* pVal) get_DirectoryCount;
				public function HRESULT(IFileSystemImage *self, BSTR* pVal) get_WorkingDirectory;
				public function HRESULT(IFileSystemImage *self, BSTR newVal) put_WorkingDirectory;
				public function HRESULT(IFileSystemImage *self, int32* pVal) get_ChangePoint;
				public function HRESULT(IFileSystemImage *self, int16* pVal) get_StrictFileSystemCompliance;
				public function HRESULT(IFileSystemImage *self, int16 newVal) put_StrictFileSystemCompliance;
				public function HRESULT(IFileSystemImage *self, int16* pVal) get_UseRestrictedCharacterSet;
				public function HRESULT(IFileSystemImage *self, int16 newVal) put_UseRestrictedCharacterSet;
				public function HRESULT(IFileSystemImage *self, FsiFileSystems* pVal) get_FileSystemsToCreate;
				public function HRESULT(IFileSystemImage *self, FsiFileSystems newVal) put_FileSystemsToCreate;
				public function HRESULT(IFileSystemImage *self, FsiFileSystems* pVal) get_FileSystemsSupported;
				public function HRESULT(IFileSystemImage *self, int32 newVal) put_UDFRevision;
				public function HRESULT(IFileSystemImage *self, int32* pVal) get_UDFRevision;
				public function HRESULT(IFileSystemImage *self, SAFEARRAY** pVal) get_UDFRevisionsSupported;
				public function HRESULT(IFileSystemImage *self, IDiscRecorder2* discRecorder) ChooseImageDefaults;
				public function HRESULT(IFileSystemImage *self, IMAPI_MEDIA_PHYSICAL_TYPE value) ChooseImageDefaultsForMediaType;
				public function HRESULT(IFileSystemImage *self, int32 newVal) put_ISO9660InterchangeLevel;
				public function HRESULT(IFileSystemImage *self, int32* pVal) get_ISO9660InterchangeLevel;
				public function HRESULT(IFileSystemImage *self, SAFEARRAY** pVal) get_ISO9660InterchangeLevelsSupported;
				public function HRESULT(IFileSystemImage *self, IFileSystemImageResult** resultStream) CreateResultImage;
				public function HRESULT(IFileSystemImage *self, BSTR fullPath, FsiItemType* itemType) Exists;
				public function HRESULT(IFileSystemImage *self, BSTR* discIdentifier) CalculateDiscIdentifier;
				public function HRESULT(IFileSystemImage *self, IDiscRecorder2* discRecorder, FsiFileSystems* fileSystems) IdentifyFileSystemsOnDisc;
				public function HRESULT(IFileSystemImage *self, FsiFileSystems fileSystems, FsiFileSystems* importDefault) GetDefaultFileSystemForImport;
				public function HRESULT(IFileSystemImage *self, FsiFileSystems* importedFileSystem) ImportFileSystem;
				public function HRESULT(IFileSystemImage *self, FsiFileSystems fileSystemToUse) ImportSpecificFileSystem;
				public function HRESULT(IFileSystemImage *self, int32 changePoint) RollbackToChangePoint;
				public function HRESULT(IFileSystemImage *self) LockInChangePoint;
				public function HRESULT(IFileSystemImage *self, BSTR name, IFsiDirectoryItem** newItem) CreateDirectoryItem;
				public function HRESULT(IFileSystemImage *self, BSTR name, IFsiFileItem** newItem) CreateFileItem;
				public function HRESULT(IFileSystemImage *self, BSTR* pVal) get_VolumeNameUDF;
				public function HRESULT(IFileSystemImage *self, BSTR* pVal) get_VolumeNameJoliet;
				public function HRESULT(IFileSystemImage *self, BSTR* pVal) get_VolumeNameISO9660;
				public function HRESULT(IFileSystemImage *self, int16* pVal) get_StageFiles;
				public function HRESULT(IFileSystemImage *self, int16 newVal) put_StageFiles;
				public function HRESULT(IFileSystemImage *self, SAFEARRAY** pVal) get_MultisessionInterfaces;
				public function HRESULT(IFileSystemImage *self, SAFEARRAY* newVal) put_MultisessionInterfaces;
			}
		}
		[CRepr]
		public struct IFileSystemImage2 : IFileSystemImage
		{
			public const new Guid IID = .(0xd7644b2c, 0x1537, 0x4767, 0xb6, 0x2f, 0xf1, 0x38, 0x7b, 0x02, 0xdd, 0xfd);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IFileSystemImage.VTable
			{
				public function HRESULT(IFileSystemImage2 *self, SAFEARRAY** pVal) get_BootImageOptionsArray;
				public function HRESULT(IFileSystemImage2 *self, SAFEARRAY* newVal) put_BootImageOptionsArray;
			}
		}
		[CRepr]
		public struct IFileSystemImage3 : IFileSystemImage2
		{
			public const new Guid IID = .(0x7cff842c, 0x7e97, 0x4807, 0x83, 0x04, 0x91, 0x0d, 0xd8, 0xf7, 0xc0, 0x51);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IFileSystemImage2.VTable
			{
				public function HRESULT(IFileSystemImage3 *self, int16* pVal) get_CreateRedundantUdfMetadataFiles;
				public function HRESULT(IFileSystemImage3 *self, int16 newVal) put_CreateRedundantUdfMetadataFiles;
				public function HRESULT(IFileSystemImage3 *self, FsiFileSystems fileSystemToProbe, int16* isAppendable) ProbeSpecificFileSystem;
			}
		}
		[CRepr]
		public struct DFileSystemImageEvents : IDispatch
		{
			public const new Guid IID = .(0x2c941fdf, 0x975b, 0x59be, 0xa9, 0x60, 0x9a, 0x2a, 0x26, 0x28, 0x53, 0xa5);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IDispatch.VTable
			{
				public function HRESULT(DFileSystemImageEvents *self, IDispatch* object, BSTR currentFile, int32 copiedSectors, int32 totalSectors) Update;
			}
		}
		[CRepr]
		public struct DFileSystemImageImportEvents : IDispatch
		{
			public const new Guid IID = .(0xd25c30f9, 0x4087, 0x4366, 0x9e, 0x24, 0xe5, 0x5b, 0xe2, 0x86, 0x42, 0x4b);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IDispatch.VTable
			{
				public function HRESULT(DFileSystemImageImportEvents *self, IDispatch* object, FsiFileSystems fileSystem, BSTR currentItem, int32 importedDirectoryItems, int32 totalDirectoryItems, int32 importedFileItems, int32 totalFileItems) UpdateImport;
			}
		}
		[CRepr]
		public struct IIsoImageManager : IDispatch
		{
			public const new Guid IID = .(0x6ca38be5, 0xfbbb, 0x4800, 0x95, 0xa1, 0xa4, 0x38, 0x86, 0x5e, 0xb0, 0xd4);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IDispatch.VTable
			{
				public function HRESULT(IIsoImageManager *self, BSTR* pVal) get_Path;
				public function HRESULT(IIsoImageManager *self, IStream** data) get_Stream;
				public function HRESULT(IIsoImageManager *self, BSTR Val) SetPath;
				public function HRESULT(IIsoImageManager *self, IStream* data) SetStream;
				public function HRESULT(IIsoImageManager *self) Validate;
			}
		}
		[CRepr]
		public struct IDiscRecorder : IUnknown
		{
			public const new Guid IID = .(0x85ac9776, 0xca88, 0x4cf2, 0x89, 0x4e, 0x09, 0x59, 0x8c, 0x07, 0x8a, 0x41);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public function HRESULT(IDiscRecorder *self, uint8* pbyUniqueID, uint32 nulIDSize, uint32 nulDriveNumber) Init;
				public function HRESULT(IDiscRecorder *self, uint8* pbyUniqueID, uint32 ulBufferSize, uint32* pulReturnSizeRequired) GetRecorderGUID;
				public function HRESULT(IDiscRecorder *self, RECORDER_TYPES* fTypeCode) GetRecorderType;
				public function HRESULT(IDiscRecorder *self, BSTR* pbstrVendorID, BSTR* pbstrProductID, BSTR* pbstrRevision) GetDisplayNames;
				public function HRESULT(IDiscRecorder *self, BSTR* pbstrBasePnPID) GetBasePnPID;
				public function HRESULT(IDiscRecorder *self, BSTR* pbstrPath) GetPath;
				public function HRESULT(IDiscRecorder *self, IPropertyStorage** ppPropStg) GetRecorderProperties;
				public function HRESULT(IDiscRecorder *self, IPropertyStorage* pPropStg) SetRecorderProperties;
				public function HRESULT(IDiscRecorder *self, DISC_RECORDER_STATE_FLAGS* pulDevStateFlags) GetRecorderState;
				public function HRESULT(IDiscRecorder *self) OpenExclusive;
				public function HRESULT(IDiscRecorder *self, MEDIA_TYPES* fMediaType, MEDIA_FLAGS* fMediaFlags) QueryMediaType;
				public function HRESULT(IDiscRecorder *self, uint8* pbSessions, uint8* pbLastTrack, uint32* ulStartAddress, uint32* ulNextWritable, uint32* ulFreeBlocks) QueryMediaInfo;
				public function HRESULT(IDiscRecorder *self) Eject;
				public function HRESULT(IDiscRecorder *self, uint8 bFullErase) Erase;
				public function HRESULT(IDiscRecorder *self) Close;
			}
		}
		[CRepr]
		public struct IEnumDiscRecorders : IUnknown
		{
			public const new Guid IID = .(0x9b1921e1, 0x54ac, 0x11d3, 0x91, 0x44, 0x00, 0x10, 0x4b, 0xa1, 0x1c, 0x5e);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public function HRESULT(IEnumDiscRecorders *self, uint32 cRecorders, IDiscRecorder** ppRecorder, uint32* pcFetched) Next;
				public function HRESULT(IEnumDiscRecorders *self, uint32 cRecorders) Skip;
				public function HRESULT(IEnumDiscRecorders *self) Reset;
				public function HRESULT(IEnumDiscRecorders *self, IEnumDiscRecorders** ppEnum) Clone;
			}
		}
		[CRepr]
		public struct IEnumDiscMasterFormats : IUnknown
		{
			public const new Guid IID = .(0xddf445e1, 0x54ba, 0x11d3, 0x91, 0x44, 0x00, 0x10, 0x4b, 0xa1, 0x1c, 0x5e);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public function HRESULT(IEnumDiscMasterFormats *self, uint32 cFormats, Guid* lpiidFormatID, uint32* pcFetched) Next;
				public function HRESULT(IEnumDiscMasterFormats *self, uint32 cFormats) Skip;
				public function HRESULT(IEnumDiscMasterFormats *self) Reset;
				public function HRESULT(IEnumDiscMasterFormats *self, IEnumDiscMasterFormats** ppEnum) Clone;
			}
		}
		[CRepr]
		public struct IRedbookDiscMaster : IUnknown
		{
			public const new Guid IID = .(0xe3bc42cd, 0x4e5c, 0x11d3, 0x91, 0x44, 0x00, 0x10, 0x4b, 0xa1, 0x1c, 0x5e);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public function HRESULT(IRedbookDiscMaster *self, int32* pnTracks) GetTotalAudioTracks;
				public function HRESULT(IRedbookDiscMaster *self, int32* pnBlocks) GetTotalAudioBlocks;
				public function HRESULT(IRedbookDiscMaster *self, int32* pnBlocks) GetUsedAudioBlocks;
				public function HRESULT(IRedbookDiscMaster *self, int32* pnBlocks) GetAvailableAudioTrackBlocks;
				public function HRESULT(IRedbookDiscMaster *self, int32* pnBlockBytes) GetAudioBlockSize;
				public function HRESULT(IRedbookDiscMaster *self, int32 nBlocks) CreateAudioTrack;
				public function HRESULT(IRedbookDiscMaster *self, uint8* pby, int32 cb) AddAudioTrackBlocks;
				public function HRESULT(IRedbookDiscMaster *self) CloseAudioTrack;
			}
		}
		[CRepr]
		public struct IJolietDiscMaster : IUnknown
		{
			public const new Guid IID = .(0xe3bc42ce, 0x4e5c, 0x11d3, 0x91, 0x44, 0x00, 0x10, 0x4b, 0xa1, 0x1c, 0x5e);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public function HRESULT(IJolietDiscMaster *self, int32* pnBlocks) GetTotalDataBlocks;
				public function HRESULT(IJolietDiscMaster *self, int32* pnBlocks) GetUsedDataBlocks;
				public function HRESULT(IJolietDiscMaster *self, int32* pnBlockBytes) GetDataBlockSize;
				public function HRESULT(IJolietDiscMaster *self, IStorage* pStorage, int32 lFileOverwrite) AddData;
				public function HRESULT(IJolietDiscMaster *self, IPropertyStorage** ppPropStg) GetJolietProperties;
				public function HRESULT(IJolietDiscMaster *self, IPropertyStorage* pPropStg) SetJolietProperties;
			}
		}
		[CRepr]
		public struct IDiscMasterProgressEvents : IUnknown
		{
			public const new Guid IID = .(0xec9e51c1, 0x4e5d, 0x11d3, 0x91, 0x44, 0x00, 0x10, 0x4b, 0xa1, 0x1c, 0x5e);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public function HRESULT(IDiscMasterProgressEvents *self, uint8* pbCancel) QueryCancel;
				public function HRESULT(IDiscMasterProgressEvents *self) NotifyPnPActivity;
				public function HRESULT(IDiscMasterProgressEvents *self, int32 nCompletedSteps, int32 nTotalSteps) NotifyAddProgress;
				public function HRESULT(IDiscMasterProgressEvents *self, int32 nCompleted, int32 nTotal) NotifyBlockProgress;
				public function HRESULT(IDiscMasterProgressEvents *self, int32 nCurrentTrack, int32 nTotalTracks) NotifyTrackProgress;
				public function HRESULT(IDiscMasterProgressEvents *self, int32 nEstimatedSeconds) NotifyPreparingBurn;
				public function HRESULT(IDiscMasterProgressEvents *self, int32 nEstimatedSeconds) NotifyClosingDisc;
				public function HRESULT(IDiscMasterProgressEvents *self, HRESULT status) NotifyBurnComplete;
				public function HRESULT(IDiscMasterProgressEvents *self, HRESULT status) NotifyEraseComplete;
			}
		}
		[CRepr]
		public struct IDiscMaster : IUnknown
		{
			public const new Guid IID = .(0x520cca62, 0x51a5, 0x11d3, 0x91, 0x44, 0x00, 0x10, 0x4b, 0xa1, 0x1c, 0x5e);
			
			public VTable* VT { get => (.)vt; }			
			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public function HRESULT(IDiscMaster *self) Open;
				public function HRESULT(IDiscMaster *self, IEnumDiscMasterFormats** ppEnum) EnumDiscMasterFormats;
				public function HRESULT(IDiscMaster *self, Guid* lpiid) GetActiveDiscMasterFormat;
				public function HRESULT(IDiscMaster *self, Guid* riid, void** ppUnk) SetActiveDiscMasterFormat;
				public function HRESULT(IDiscMaster *self, IEnumDiscRecorders** ppEnum) EnumDiscRecorders;
				public function HRESULT(IDiscMaster *self, IDiscRecorder** ppRecorder) GetActiveDiscRecorder;
				public function HRESULT(IDiscMaster *self, IDiscRecorder* pRecorder) SetActiveDiscRecorder;
				public function HRESULT(IDiscMaster *self) ClearFormatContent;
				public function HRESULT(IDiscMaster *self, IDiscMasterProgressEvents* pEvents, uint* pvCookie) ProgressAdvise;
				public function HRESULT(IDiscMaster *self, uint vCookie) ProgressUnadvise;
				public function HRESULT(IDiscMaster *self, uint8 bSimulate, uint8 bEjectAfterBurn) RecordDisc;
				public function HRESULT(IDiscMaster *self) Close;
			}
		}
		
		// --- Functions ---
		
		[Import("mapi32.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern int32 OpenIMsgSession(IMalloc* lpMalloc, uint32 ulFlags, _MSGSESS** lppMsgSess);
		[Import("mapi32.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern void CloseIMsgSession(_MSGSESS* lpMsgSess);
		[Import("mapi32.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern int32 OpenIMsgOnIStg(_MSGSESS* lpMsgSess, LPALLOCATEBUFFER lpAllocateBuffer, LPALLOCATEMORE lpAllocateMore, LPFREEBUFFER lpFreeBuffer, IMalloc* lpMalloc, void* lpMapiSup, IStorage* lpStg, MSGCALLRELEASE* lpfMsgCallRelease, uint32 ulCallerData, uint32 ulFlags, IMessage** lppMsg);
		[Import("mapi32.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern HRESULT GetAttribIMsgOnIStg(void* lpObject, SPropTagArray* lpPropTagArray, SPropAttrArray** lppPropAttrArray);
		[Import("mapi32.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern HRESULT SetAttribIMsgOnIStg(void* lpObject, SPropTagArray* lpPropTags, SPropAttrArray* lpPropAttrs, SPropProblemArray** lppPropProblems);
		[Import("mapi32.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern int32 MapStorageSCode(int32 StgSCode);
		
	}
}

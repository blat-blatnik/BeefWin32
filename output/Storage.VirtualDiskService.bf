using System;

// namespace Storage.VirtualDiskService
namespace Win32
{
	extension Win32
	{
		// --- Constants ---
		
		public const uint32 VDS_NF_VOLUME_ARRIVE = 4;
		public const uint32 VDS_NF_VOLUME_DEPART = 5;
		public const uint32 VDS_NF_VOLUME_MODIFY = 6;
		public const uint32 VDS_NF_VOLUME_REBUILDING_PROGRESS = 7;
		public const uint32 VDS_NF_PARTITION_ARRIVE = 11;
		public const uint32 VDS_NF_PARTITION_DEPART = 12;
		public const uint32 VDS_NF_PARTITION_MODIFY = 13;
		public const uint32 VDS_NF_SUB_SYSTEM_ARRIVE = 101;
		public const uint32 VDS_NF_SUB_SYSTEM_DEPART = 102;
		public const uint32 VDS_NF_PORTAL_ARRIVE = 123;
		public const uint32 VDS_NF_PORTAL_DEPART = 124;
		public const uint32 VDS_NF_PORTAL_MODIFY = 125;
		public const uint32 VDS_NF_TARGET_ARRIVE = 126;
		public const uint32 VDS_NF_TARGET_DEPART = 127;
		public const uint32 VDS_NF_TARGET_MODIFY = 128;
		public const uint32 VDS_NF_PORTAL_GROUP_ARRIVE = 129;
		public const uint32 VDS_NF_PORTAL_GROUP_DEPART = 130;
		public const uint32 VDS_NF_PORTAL_GROUP_MODIFY = 131;
		public const uint32 VDS_NF_SUB_SYSTEM_MODIFY = 151;
		public const uint32 VDS_NF_DRIVE_LETTER_FREE = 201;
		public const uint32 VDS_NF_DRIVE_LETTER_ASSIGN = 202;
		public const uint32 VDS_NF_MOUNT_POINTS_CHANGE = 205;
		public const uint32 VDS_NF_FILE_SYSTEM_SHRINKING_PROGRESS = 206;
		public const uint32 VDS_NF_SERVICE_OUT_OF_SYNC = 301;
		public const uint32 GPT_PARTITION_NAME_LENGTH = 36;
		public const int32 VDS_HINT_FASTCRASHRECOVERYREQUIRED = 1;
		public const int32 VDS_HINT_MOSTLYREADS = 2;
		public const int32 VDS_HINT_OPTIMIZEFORSEQUENTIALREADS = 4;
		public const int32 VDS_HINT_OPTIMIZEFORSEQUENTIALWRITES = 8;
		public const int32 VDS_HINT_READBACKVERIFYENABLED = 16;
		public const int32 VDS_HINT_REMAPENABLED = 32;
		public const int32 VDS_HINT_WRITETHROUGHCACHINGENABLED = 64;
		public const int32 VDS_HINT_HARDWARECHECKSUMENABLED = 128;
		public const int32 VDS_HINT_ISYANKABLE = 256;
		public const int32 VDS_HINT_ALLOCATEHOTSPARE = 512;
		public const int32 VDS_HINT_BUSTYPE = 1024;
		public const int32 VDS_HINT_USEMIRROREDCACHE = 2048;
		public const int32 VDS_HINT_READCACHINGENABLED = 4096;
		public const int32 VDS_HINT_WRITECACHINGENABLED = 8192;
		public const int32 VDS_HINT_MEDIASCANENABLED = 16384;
		public const int32 VDS_HINT_CONSISTENCYCHECKENABLED = 32768;
		public const uint32 VDS_REBUILD_PRIORITY_MIN = 0;
		public const uint32 VDS_REBUILD_PRIORITY_MAX = 16;
		public const int32 VDS_POOL_ATTRIB_RAIDTYPE = 1;
		public const int32 VDS_POOL_ATTRIB_BUSTYPE = 2;
		public const int32 VDS_POOL_ATTRIB_ALLOW_SPINDOWN = 4;
		public const int32 VDS_POOL_ATTRIB_THIN_PROVISION = 8;
		public const int32 VDS_POOL_ATTRIB_NO_SINGLE_POF = 16;
		public const int32 VDS_POOL_ATTRIB_DATA_RDNCY_MAX = 32;
		public const int32 VDS_POOL_ATTRIB_DATA_RDNCY_MIN = 64;
		public const int32 VDS_POOL_ATTRIB_DATA_RDNCY_DEF = 128;
		public const int32 VDS_POOL_ATTRIB_PKG_RDNCY_MAX = 256;
		public const int32 VDS_POOL_ATTRIB_PKG_RDNCY_MIN = 512;
		public const int32 VDS_POOL_ATTRIB_PKG_RDNCY_DEF = 1024;
		public const int32 VDS_POOL_ATTRIB_STRIPE_SIZE = 2048;
		public const int32 VDS_POOL_ATTRIB_STRIPE_SIZE_MAX = 4096;
		public const int32 VDS_POOL_ATTRIB_STRIPE_SIZE_MIN = 8192;
		public const int32 VDS_POOL_ATTRIB_STRIPE_SIZE_DEF = 16384;
		public const int32 VDS_POOL_ATTRIB_NUM_CLMNS = 32768;
		public const int32 VDS_POOL_ATTRIB_NUM_CLMNS_MAX = 65536;
		public const int32 VDS_POOL_ATTRIB_NUM_CLMNS_MIN = 131072;
		public const int32 VDS_POOL_ATTRIB_NUM_CLMNS_DEF = 262144;
		public const int32 VDS_POOL_ATTRIB_DATA_AVL_HINT = 524288;
		public const int32 VDS_POOL_ATTRIB_ACCS_RNDM_HINT = 1048576;
		public const int32 VDS_POOL_ATTRIB_ACCS_DIR_HINT = 2097152;
		public const int32 VDS_POOL_ATTRIB_ACCS_SIZE_HINT = 4194304;
		public const int32 VDS_POOL_ATTRIB_ACCS_LTNCY_HINT = 8388608;
		public const int32 VDS_POOL_ATTRIB_ACCS_BDW_WT_HINT = 16777216;
		public const int32 VDS_POOL_ATTRIB_STOR_COST_HINT = 33554432;
		public const int32 VDS_POOL_ATTRIB_STOR_EFFCY_HINT = 67108864;
		public const int32 VDS_POOL_ATTRIB_CUSTOM_ATTRIB = 134217728;
		public const uint32 VDS_ATTACH_VIRTUAL_DISK_FLAG_USE_FILE_ACL = 1;
		public const Guid CLSID_VdsLoader = .(0x9c38ed61, 0xd565, 0x4728, 0xae, 0xee, 0xc8, 0x09, 0x52, 0xf0, 0xec, 0xde);
		public const Guid CLSID_VdsService = .(0x7d1933cb, 0x86f6, 0x4a98, 0x86, 0x28, 0x01, 0xbe, 0x94, 0xc9, 0xa5, 0x75);
		public const uint32 MAX_FS_NAME_SIZE = 8;
		public const uint32 MAX_FS_FORMAT_SUPPORT_NAME_SIZE = 32;
		public const uint32 MAX_FS_ALLOWED_CLUSTER_SIZES_SIZE = 32;
		public const uint32 VER_VDS_LUN_INFORMATION = 1;
		public const HRESULT VDS_E_NOT_SUPPORTED = -2147212288;
		public const HRESULT VDS_E_INITIALIZED_FAILED = -2147212287;
		public const HRESULT VDS_E_INITIALIZE_NOT_CALLED = -2147212286;
		public const HRESULT VDS_E_ALREADY_REGISTERED = -2147212285;
		public const HRESULT VDS_E_ANOTHER_CALL_IN_PROGRESS = -2147212284;
		public const HRESULT VDS_E_OBJECT_NOT_FOUND = -2147212283;
		public const HRESULT VDS_E_INVALID_SPACE = -2147212282;
		public const HRESULT VDS_E_PARTITION_LIMIT_REACHED = -2147212281;
		public const HRESULT VDS_E_PARTITION_NOT_EMPTY = -2147212280;
		public const HRESULT VDS_E_OPERATION_PENDING = -2147212279;
		public const HRESULT VDS_E_OPERATION_DENIED = -2147212278;
		public const HRESULT VDS_E_OBJECT_DELETED = -2147212277;
		public const HRESULT VDS_E_CANCEL_TOO_LATE = -2147212276;
		public const HRESULT VDS_E_OPERATION_CANCELED = -2147212275;
		public const HRESULT VDS_E_CANNOT_EXTEND = -2147212274;
		public const HRESULT VDS_E_NOT_ENOUGH_SPACE = -2147212273;
		public const HRESULT VDS_E_NOT_ENOUGH_DRIVE = -2147212272;
		public const HRESULT VDS_E_BAD_COOKIE = -2147212271;
		public const HRESULT VDS_E_NO_MEDIA = -2147212270;
		public const HRESULT VDS_E_DEVICE_IN_USE = -2147212269;
		public const HRESULT VDS_E_DISK_NOT_EMPTY = -2147212268;
		public const HRESULT VDS_E_INVALID_OPERATION = -2147212267;
		public const HRESULT VDS_E_PATH_NOT_FOUND = -2147212266;
		public const HRESULT VDS_E_DISK_NOT_INITIALIZED = -2147212265;
		public const HRESULT VDS_E_NOT_AN_UNALLOCATED_DISK = -2147212264;
		public const HRESULT VDS_E_UNRECOVERABLE_ERROR = -2147212263;
		public const HRESULT VDS_S_DISK_PARTIALLY_CLEANED = 271386;
		public const HRESULT VDS_E_DMADMIN_SERVICE_CONNECTION_FAILED = -2147212261;
		public const HRESULT VDS_E_PROVIDER_INITIALIZATION_FAILED = -2147212260;
		public const HRESULT VDS_E_OBJECT_EXISTS = -2147212259;
		public const HRESULT VDS_E_NO_DISKS_FOUND = -2147212258;
		public const HRESULT VDS_E_PROVIDER_CACHE_CORRUPT = -2147212257;
		public const HRESULT VDS_E_DMADMIN_METHOD_CALL_FAILED = -2147212256;
		public const HRESULT VDS_S_PROVIDER_ERROR_LOADING_CACHE = 271393;
		public const HRESULT VDS_E_PROVIDER_VOL_DEVICE_NAME_NOT_FOUND = -2147212254;
		public const HRESULT VDS_E_PROVIDER_VOL_OPEN = -2147212253;
		public const HRESULT VDS_E_DMADMIN_CORRUPT_NOTIFICATION = -2147212252;
		public const HRESULT VDS_E_INCOMPATIBLE_FILE_SYSTEM = -2147212251;
		public const HRESULT VDS_E_INCOMPATIBLE_MEDIA = -2147212250;
		public const HRESULT VDS_E_ACCESS_DENIED = -2147212249;
		public const HRESULT VDS_E_MEDIA_WRITE_PROTECTED = -2147212248;
		public const HRESULT VDS_E_BAD_LABEL = -2147212247;
		public const HRESULT VDS_E_CANT_QUICK_FORMAT = -2147212246;
		public const HRESULT VDS_E_IO_ERROR = -2147212245;
		public const HRESULT VDS_E_VOLUME_TOO_SMALL = -2147212244;
		public const HRESULT VDS_E_VOLUME_TOO_BIG = -2147212243;
		public const HRESULT VDS_E_CLUSTER_SIZE_TOO_SMALL = -2147212242;
		public const HRESULT VDS_E_CLUSTER_SIZE_TOO_BIG = -2147212241;
		public const HRESULT VDS_E_CLUSTER_COUNT_BEYOND_32BITS = -2147212240;
		public const HRESULT VDS_E_OBJECT_STATUS_FAILED = -2147212239;
		public const HRESULT VDS_E_VOLUME_INCOMPLETE = -2147212238;
		public const HRESULT VDS_E_EXTENT_SIZE_LESS_THAN_MIN = -2147212237;
		public const HRESULT VDS_S_UPDATE_BOOTFILE_FAILED = 271412;
		public const HRESULT VDS_S_BOOT_PARTITION_NUMBER_CHANGE = 271414;
		public const HRESULT VDS_E_BOOT_PARTITION_NUMBER_CHANGE = -2147212234;
		public const HRESULT VDS_E_NO_FREE_SPACE = -2147212233;
		public const HRESULT VDS_E_ACTIVE_PARTITION = -2147212232;
		public const HRESULT VDS_E_PARTITION_OF_UNKNOWN_TYPE = -2147212231;
		public const HRESULT VDS_E_LEGACY_VOLUME_FORMAT = -2147212230;
		public const HRESULT VDS_E_NON_CONTIGUOUS_DATA_PARTITIONS = -2147212229;
		public const HRESULT VDS_E_MIGRATE_OPEN_VOLUME = -2147212228;
		public const HRESULT VDS_E_VOLUME_NOT_ONLINE = -2147212227;
		public const HRESULT VDS_E_VOLUME_NOT_HEALTHY = -2147212226;
		public const HRESULT VDS_E_VOLUME_SPANS_DISKS = -2147212225;
		public const HRESULT VDS_E_REQUIRES_CONTIGUOUS_DISK_SPACE = -2147212224;
		public const HRESULT VDS_E_BAD_PROVIDER_DATA = -2147212223;
		public const HRESULT VDS_E_PROVIDER_FAILURE = -2147212222;
		public const HRESULT VDS_S_VOLUME_COMPRESS_FAILED = 271427;
		public const HRESULT VDS_E_PACK_OFFLINE = -2147212220;
		public const HRESULT VDS_E_VOLUME_NOT_A_MIRROR = -2147212219;
		public const HRESULT VDS_E_NO_EXTENTS_FOR_VOLUME = -2147212218;
		public const HRESULT VDS_E_DISK_NOT_LOADED_TO_CACHE = -2147212217;
		public const HRESULT VDS_E_INTERNAL_ERROR = -2147212216;
		public const HRESULT VDS_S_ACCESS_PATH_NOT_DELETED = 279108;
		public const HRESULT VDS_E_PROVIDER_TYPE_NOT_SUPPORTED = -2147212214;
		public const HRESULT VDS_E_DISK_NOT_ONLINE = -2147212213;
		public const HRESULT VDS_E_DISK_IN_USE_BY_VOLUME = -2147212212;
		public const HRESULT VDS_S_IN_PROGRESS = 271437;
		public const HRESULT VDS_E_ASYNC_OBJECT_FAILURE = -2147212210;
		public const HRESULT VDS_E_VOLUME_NOT_MOUNTED = -2147212209;
		public const HRESULT VDS_E_PACK_NOT_FOUND = -2147212208;
		public const HRESULT VDS_E_IMPORT_SET_INCOMPLETE = -2147212207;
		public const HRESULT VDS_E_DISK_NOT_IMPORTED = -2147212206;
		public const HRESULT VDS_E_OBJECT_OUT_OF_SYNC = -2147212205;
		public const HRESULT VDS_E_MISSING_DISK = -2147212204;
		public const HRESULT VDS_E_DISK_PNP_REG_CORRUPT = -2147212203;
		public const HRESULT VDS_E_LBN_REMAP_ENABLED_FLAG = -2147212202;
		public const HRESULT VDS_E_NO_DRIVELETTER_FLAG = -2147212201;
		public const HRESULT VDS_E_REVERT_ON_CLOSE = -2147212200;
		public const HRESULT VDS_E_REVERT_ON_CLOSE_SET = -2147212199;
		public const HRESULT VDS_E_IA64_BOOT_MIRRORED_TO_MBR = -2147212198;
		public const HRESULT VDS_S_IA64_BOOT_MIRRORED_TO_MBR = 271450;
		public const HRESULT VDS_S_UNABLE_TO_GET_GPT_ATTRIBUTES = 271451;
		public const HRESULT VDS_E_VOLUME_TEMPORARILY_DISMOUNTED = -2147212196;
		public const HRESULT VDS_E_VOLUME_PERMANENTLY_DISMOUNTED = -2147212195;
		public const HRESULT VDS_E_VOLUME_HAS_PATH = -2147212194;
		public const HRESULT VDS_E_TIMEOUT = -2147212193;
		public const HRESULT VDS_E_REPAIR_VOLUMESTATE = -2147212192;
		public const HRESULT VDS_E_LDM_TIMEOUT = -2147212191;
		public const HRESULT VDS_E_REVERT_ON_CLOSE_MISMATCH = -2147212190;
		public const HRESULT VDS_E_RETRY = -2147212189;
		public const HRESULT VDS_E_ONLINE_PACK_EXISTS = -2147212188;
		public const HRESULT VDS_S_EXTEND_FILE_SYSTEM_FAILED = 271461;
		public const HRESULT VDS_E_EXTEND_FILE_SYSTEM_FAILED = -2147212186;
		public const HRESULT VDS_S_MBR_BOOT_MIRRORED_TO_GPT = 271463;
		public const HRESULT VDS_E_MAX_USABLE_MBR = -2147212184;
		public const HRESULT VDS_S_GPT_BOOT_MIRRORED_TO_MBR = -2147212183;
		public const HRESULT VDS_E_NO_SOFTWARE_PROVIDERS_LOADED = -2147212032;
		public const HRESULT VDS_E_DISK_NOT_MISSING = -2147212031;
		public const HRESULT VDS_E_NO_VOLUME_LAYOUT = -2147212030;
		public const HRESULT VDS_E_CORRUPT_VOLUME_INFO = -2147212029;
		public const HRESULT VDS_E_INVALID_ENUMERATOR = -2147212028;
		public const HRESULT VDS_E_DRIVER_INTERNAL_ERROR = -2147212027;
		public const HRESULT VDS_E_VOLUME_INVALID_NAME = -2147212025;
		public const HRESULT VDS_S_DISK_IS_MISSING = 271624;
		public const HRESULT VDS_E_CORRUPT_PARTITION_INFO = -2147212023;
		public const HRESULT VDS_S_NONCONFORMANT_PARTITION_INFO = 271626;
		public const HRESULT VDS_E_CORRUPT_EXTENT_INFO = -2147212021;
		public const HRESULT VDS_E_DUP_EMPTY_PACK_GUID = -2147212020;
		public const HRESULT VDS_E_DRIVER_NO_PACK_NAME = -2147212019;
		public const HRESULT VDS_S_SYSTEM_PARTITION = 271630;
		public const HRESULT VDS_E_BAD_PNP_MESSAGE = -2147212017;
		public const HRESULT VDS_E_NO_PNP_DISK_ARRIVE = -2147212016;
		public const HRESULT VDS_E_NO_PNP_VOLUME_ARRIVE = -2147212015;
		public const HRESULT VDS_E_NO_PNP_DISK_REMOVE = -2147212014;
		public const HRESULT VDS_E_NO_PNP_VOLUME_REMOVE = -2147212013;
		public const HRESULT VDS_E_PROVIDER_EXITING = -2147212012;
		public const HRESULT VDS_E_EXTENT_EXCEEDS_DISK_FREE_SPACE = -2147212011;
		public const HRESULT VDS_E_MEMBER_SIZE_INVALID = -2147212010;
		public const HRESULT VDS_S_NO_NOTIFICATION = 271639;
		public const HRESULT VDS_S_DEFAULT_PLEX_MEMBER_IDS = 271640;
		public const HRESULT VDS_E_INVALID_DISK = -2147212007;
		public const HRESULT VDS_E_INVALID_PACK = -2147212006;
		public const HRESULT VDS_E_VOLUME_ON_DISK = -2147212005;
		public const HRESULT VDS_E_DRIVER_INVALID_PARAM = -2147212004;
		public const HRESULT VDS_E_TARGET_PACK_NOT_EMPTY = -2147212003;
		public const HRESULT VDS_E_CANNOT_SHRINK = -2147212002;
		public const HRESULT VDS_E_MULTIPLE_PACKS = -2147212001;
		public const HRESULT VDS_E_PACK_ONLINE = -2147212000;
		public const HRESULT VDS_E_INVALID_PLEX_COUNT = -2147211999;
		public const HRESULT VDS_E_INVALID_MEMBER_COUNT = -2147211998;
		public const HRESULT VDS_E_INVALID_PLEX_ORDER = -2147211997;
		public const HRESULT VDS_E_INVALID_MEMBER_ORDER = -2147211996;
		public const HRESULT VDS_E_INVALID_STRIPE_SIZE = -2147211995;
		public const HRESULT VDS_E_INVALID_DISK_COUNT = -2147211994;
		public const HRESULT VDS_E_INVALID_EXTENT_COUNT = -2147211993;
		public const HRESULT VDS_E_SOURCE_IS_TARGET_PACK = -2147211992;
		public const HRESULT VDS_E_VOLUME_DISK_COUNT_MAX_EXCEEDED = -2147211991;
		public const HRESULT VDS_E_CORRUPT_NOTIFICATION_INFO = -2147211990;
		public const HRESULT VDS_E_INVALID_PLEX_GUID = -2147211988;
		public const HRESULT VDS_E_DISK_NOT_FOUND_IN_PACK = -2147211987;
		public const HRESULT VDS_E_DUPLICATE_DISK = -2147211986;
		public const HRESULT VDS_E_LAST_VALID_DISK = -2147211985;
		public const HRESULT VDS_E_INVALID_SECTOR_SIZE = -2147211984;
		public const HRESULT VDS_E_ONE_EXTENT_PER_DISK = -2147211983;
		public const HRESULT VDS_E_INVALID_BLOCK_SIZE = -2147211982;
		public const HRESULT VDS_E_PLEX_SIZE_INVALID = -2147211981;
		public const HRESULT VDS_E_NO_EXTENTS_FOR_PLEX = -2147211980;
		public const HRESULT VDS_E_INVALID_PLEX_TYPE = -2147211979;
		public const HRESULT VDS_E_INVALID_PLEX_BLOCK_SIZE = -2147211978;
		public const HRESULT VDS_E_NO_HEALTHY_DISKS = -2147211977;
		public const HRESULT VDS_E_CONFIG_LIMIT = -2147211976;
		public const HRESULT VDS_E_DISK_CONFIGURATION_CORRUPTED = -2147211975;
		public const HRESULT VDS_E_DISK_CONFIGURATION_NOT_IN_SYNC = -2147211974;
		public const HRESULT VDS_E_DISK_CONFIGURATION_UPDATE_FAILED = -2147211973;
		public const HRESULT VDS_E_DISK_DYNAMIC = -2147211972;
		public const HRESULT VDS_E_DRIVER_OBJECT_NOT_FOUND = -2147211971;
		public const HRESULT VDS_E_PARTITION_NOT_CYLINDER_ALIGNED = -2147211970;
		public const HRESULT VDS_E_DISK_LAYOUT_PARTITIONS_TOO_SMALL = -2147211969;
		public const HRESULT VDS_E_DISK_IO_FAILING = -2147211968;
		public const HRESULT VDS_E_DYNAMIC_DISKS_NOT_SUPPORTED = -2147211967;
		public const HRESULT VDS_E_FAULT_TOLERANT_DISKS_NOT_SUPPORTED = -2147211966;
		public const HRESULT VDS_E_GPT_ATTRIBUTES_INVALID = -2147211965;
		public const HRESULT VDS_E_MEMBER_IS_HEALTHY = -2147211964;
		public const HRESULT VDS_E_MEMBER_REGENERATING = -2147211963;
		public const HRESULT VDS_E_PACK_NAME_INVALID = -2147211962;
		public const HRESULT VDS_E_PLEX_IS_HEALTHY = -2147211961;
		public const HRESULT VDS_E_PLEX_LAST_ACTIVE = -2147211960;
		public const HRESULT VDS_E_PLEX_MISSING = -2147211959;
		public const HRESULT VDS_E_MEMBER_MISSING = -2147211958;
		public const HRESULT VDS_E_PLEX_REGENERATING = -2147211957;
		public const HRESULT VDS_E_UNEXPECTED_DISK_LAYOUT_CHANGE = -2147211955;
		public const HRESULT VDS_E_INVALID_VOLUME_LENGTH = -2147211954;
		public const HRESULT VDS_E_VOLUME_LENGTH_NOT_SECTOR_SIZE_MULTIPLE = -2147211953;
		public const HRESULT VDS_E_VOLUME_NOT_RETAINED = -2147211952;
		public const HRESULT VDS_E_VOLUME_RETAINED = -2147211951;
		public const HRESULT VDS_E_ALIGN_BEYOND_FIRST_CYLINDER = -2147211949;
		public const HRESULT VDS_E_ALIGN_NOT_SECTOR_SIZE_MULTIPLE = -2147211948;
		public const HRESULT VDS_E_ALIGN_NOT_ZERO = -2147211947;
		public const HRESULT VDS_E_CACHE_CORRUPT = -2147211946;
		public const HRESULT VDS_E_CANNOT_CLEAR_VOLUME_FLAG = -2147211945;
		public const HRESULT VDS_E_DISK_BEING_CLEANED = -2147211944;
		public const HRESULT VDS_E_DISK_NOT_CONVERTIBLE = -2147211943;
		public const HRESULT VDS_E_DISK_REMOVEABLE = -2147211942;
		public const HRESULT VDS_E_DISK_REMOVEABLE_NOT_EMPTY = -2147211941;
		public const HRESULT VDS_E_DRIVE_LETTER_NOT_FREE = -2147211940;
		public const HRESULT VDS_E_EXTEND_MULTIPLE_DISKS_NOT_SUPPORTED = -2147211939;
		public const HRESULT VDS_E_INVALID_DRIVE_LETTER = -2147211938;
		public const HRESULT VDS_E_INVALID_DRIVE_LETTER_COUNT = -2147211937;
		public const HRESULT VDS_E_INVALID_FS_FLAG = -2147211936;
		public const HRESULT VDS_E_INVALID_FS_TYPE = -2147211935;
		public const HRESULT VDS_E_INVALID_OBJECT_TYPE = -2147211934;
		public const HRESULT VDS_E_INVALID_PARTITION_LAYOUT = -2147211933;
		public const HRESULT VDS_E_INVALID_PARTITION_STYLE = -2147211932;
		public const HRESULT VDS_E_INVALID_PARTITION_TYPE = -2147211931;
		public const HRESULT VDS_E_INVALID_PROVIDER_CLSID = -2147211930;
		public const HRESULT VDS_E_INVALID_PROVIDER_ID = -2147211929;
		public const HRESULT VDS_E_INVALID_PROVIDER_NAME = -2147211928;
		public const HRESULT VDS_E_INVALID_PROVIDER_TYPE = -2147211927;
		public const HRESULT VDS_E_INVALID_PROVIDER_VERSION_GUID = -2147211926;
		public const HRESULT VDS_E_INVALID_PROVIDER_VERSION_STRING = -2147211925;
		public const HRESULT VDS_E_INVALID_QUERY_PROVIDER_FLAG = -2147211924;
		public const HRESULT VDS_E_INVALID_SERVICE_FLAG = -2147211923;
		public const HRESULT VDS_E_INVALID_VOLUME_FLAG = -2147211922;
		public const HRESULT VDS_E_PARTITION_NOT_OEM = -2147211921;
		public const HRESULT VDS_E_PARTITION_PROTECTED = -2147211920;
		public const HRESULT VDS_E_PARTITION_STYLE_MISMATCH = -2147211919;
		public const HRESULT VDS_E_PROVIDER_INTERNAL_ERROR = -2147211918;
		public const HRESULT VDS_E_SHRINK_SIZE_LESS_THAN_MIN = -2147211917;
		public const HRESULT VDS_E_SHRINK_SIZE_TOO_BIG = -2147211916;
		public const HRESULT VDS_E_UNRECOVERABLE_PROVIDER_ERROR = -2147211915;
		public const HRESULT VDS_E_VOLUME_HIDDEN = -2147211914;
		public const HRESULT VDS_S_DISMOUNT_FAILED = 271735;
		public const HRESULT VDS_S_REMOUNT_FAILED = 271736;
		public const HRESULT VDS_E_FLAG_ALREADY_SET = -2147211911;
		public const HRESULT VDS_S_RESYNC_NOTIFICATION_TASK_FAILED = 271738;
		public const HRESULT VDS_E_DISTINCT_VOLUME = -2147211909;
		public const HRESULT VDS_E_VOLUME_NOT_FOUND_IN_PACK = -2147211908;
		public const HRESULT VDS_E_PARTITION_NON_DATA = -2147211907;
		public const HRESULT VDS_E_CRITICAL_PLEX = -2147211906;
		public const HRESULT VDS_E_VOLUME_SYNCHRONIZING = -2147211905;
		public const HRESULT VDS_E_VOLUME_REGENERATING = -2147211904;
		public const HRESULT VDS_S_VSS_FLUSH_AND_HOLD_WRITES = 271745;
		public const HRESULT VDS_S_VSS_RELEASE_WRITES = 271746;
		public const HRESULT VDS_S_FS_LOCK = 271747;
		public const HRESULT VDS_E_READONLY = -2147211900;
		public const HRESULT VDS_E_INVALID_VOLUME_TYPE = -2147211899;
		public const HRESULT VDS_E_BAD_BOOT_DISK = -2147211898;
		public const HRESULT VDS_E_LOG_UPDATE = -2147211897;
		public const HRESULT VDS_E_VOLUME_MIRRORED = -2147211896;
		public const HRESULT VDS_E_VOLUME_SIMPLE_SPANNED = -2147211895;
		public const HRESULT VDS_E_NO_VALID_LOG_COPIES = -2147211894;
		public const HRESULT VDS_S_PLEX_NOT_LOADED_TO_CACHE = 271755;
		public const HRESULT VDS_E_PLEX_NOT_LOADED_TO_CACHE = -2147211893;
		public const HRESULT VDS_E_PARTITION_MSR = -2147211892;
		public const HRESULT VDS_E_PARTITION_LDM = -2147211891;
		public const HRESULT VDS_S_WINPE_BOOTENTRY = 271758;
		public const HRESULT VDS_E_ALIGN_NOT_A_POWER_OF_TWO = -2147211889;
		public const HRESULT VDS_E_ALIGN_IS_ZERO = -2147211888;
		public const HRESULT VDS_E_SHRINK_IN_PROGRESS = -2147211887;
		public const HRESULT VDS_E_CANT_INVALIDATE_FVE = -2147211886;
		public const HRESULT VDS_E_FS_NOT_DETERMINED = -2147211885;
		public const HRESULT VDS_E_DISK_NOT_OFFLINE = -2147211883;
		public const HRESULT VDS_E_FAILED_TO_ONLINE_DISK = -2147211882;
		public const HRESULT VDS_E_FAILED_TO_OFFLINE_DISK = -2147211881;
		public const HRESULT VDS_E_BAD_REVISION_NUMBER = -2147211880;
		public const HRESULT VDS_E_SHRINK_USER_CANCELLED = -2147211879;
		public const HRESULT VDS_E_SHRINK_DIRTY_VOLUME = -2147211878;
		public const HRESULT VDS_S_NAME_TRUNCATED = 272128;
		public const HRESULT VDS_E_NAME_NOT_UNIQUE = -2147211519;
		public const HRESULT VDS_S_STATUSES_INCOMPLETELY_SET = 272130;
		public const HRESULT VDS_E_ADDRESSES_INCOMPLETELY_SET = -2147211517;
		public const HRESULT VDS_E_SECURITY_INCOMPLETELY_SET = -2147211515;
		public const HRESULT VDS_E_TARGET_SPECIFIC_NOT_SUPPORTED = -2147211514;
		public const HRESULT VDS_E_INITIATOR_SPECIFIC_NOT_SUPPORTED = -2147211513;
		public const HRESULT VDS_E_ISCSI_LOGIN_FAILED = -2147211512;
		public const HRESULT VDS_E_ISCSI_LOGOUT_FAILED = -2147211511;
		public const HRESULT VDS_E_ISCSI_SESSION_NOT_FOUND = -2147211510;
		public const HRESULT VDS_E_ASSOCIATED_LUNS_EXIST = -2147211509;
		public const HRESULT VDS_E_ASSOCIATED_PORTALS_EXIST = -2147211508;
		public const HRESULT VDS_E_NO_DISCOVERY_DOMAIN = -2147211507;
		public const HRESULT VDS_E_MULTIPLE_DISCOVERY_DOMAINS = -2147211506;
		public const HRESULT VDS_E_NO_DISK_PATHNAME = -2147211505;
		public const HRESULT VDS_E_ISCSI_LOGOUT_INCOMPLETE = -2147211504;
		public const HRESULT VDS_E_NO_VOLUME_PATHNAME = -2147211503;
		public const HRESULT VDS_E_PROVIDER_CACHE_OUTOFSYNC = -2147211502;
		public const HRESULT VDS_E_NO_IMPORT_TARGET = -2147211501;
		public const HRESULT VDS_S_ALREADY_EXISTS = 272148;
		public const HRESULT VDS_S_PROPERTIES_INCOMPLETE = 272149;
		public const HRESULT VDS_S_ISCSI_SESSION_NOT_FOUND_PERSISTENT_LOGIN_REMOVED = 272384;
		public const HRESULT VDS_S_ISCSI_PERSISTENT_LOGIN_MAY_NOT_BE_REMOVED = 272385;
		public const HRESULT VDS_S_ISCSI_LOGIN_ALREAD_EXISTS = 272386;
		public const HRESULT VDS_E_UNABLE_TO_FIND_BOOT_DISK = -2147211261;
		public const HRESULT VDS_E_INCORRECT_BOOT_VOLUME_EXTENT_INFO = -2147211260;
		public const HRESULT VDS_E_GET_SAN_POLICY = -2147211259;
		public const HRESULT VDS_E_SET_SAN_POLICY = -2147211258;
		public const HRESULT VDS_E_BOOT_DISK = -2147211257;
		public const HRESULT VDS_S_DISK_MOUNT_FAILED = 272392;
		public const HRESULT VDS_S_DISK_DISMOUNT_FAILED = 272393;
		public const HRESULT VDS_E_DISK_IS_OFFLINE = -2147211254;
		public const HRESULT VDS_E_DISK_IS_READ_ONLY = -2147211253;
		public const HRESULT VDS_E_PAGEFILE_DISK = -2147211252;
		public const HRESULT VDS_E_HIBERNATION_FILE_DISK = -2147211251;
		public const HRESULT VDS_E_CRASHDUMP_DISK = -2147211250;
		public const HRESULT VDS_E_UNABLE_TO_FIND_SYSTEM_DISK = -2147211249;
		public const HRESULT VDS_E_INCORRECT_SYSTEM_VOLUME_EXTENT_INFO = -2147211248;
		public const HRESULT VDS_E_SYSTEM_DISK = -2147211247;
		public const HRESULT VDS_E_VOLUME_SHRINK_FVE_LOCKED = -2147211246;
		public const HRESULT VDS_E_VOLUME_SHRINK_FVE_CORRUPT = -2147211245;
		public const HRESULT VDS_E_VOLUME_SHRINK_FVE_RECOVERY = -2147211244;
		public const HRESULT VDS_E_VOLUME_SHRINK_FVE = -2147211243;
		public const HRESULT VDS_E_SHRINK_OVER_DATA = -2147211242;
		public const HRESULT VDS_E_INVALID_SHRINK_SIZE = -2147211241;
		public const HRESULT VDS_E_LUN_DISK_MISSING = -2147211240;
		public const HRESULT VDS_E_LUN_DISK_FAILED = -2147211239;
		public const HRESULT VDS_E_LUN_DISK_NOT_READY = -2147211238;
		public const HRESULT VDS_E_LUN_DISK_NO_MEDIA = -2147211237;
		public const HRESULT VDS_E_LUN_NOT_READY = -2147211236;
		public const HRESULT VDS_E_LUN_OFFLINE = -2147211235;
		public const HRESULT VDS_E_LUN_FAILED = -2147211234;
		public const HRESULT VDS_E_VOLUME_EXTEND_FVE_LOCKED = -2147211233;
		public const HRESULT VDS_E_VOLUME_EXTEND_FVE_CORRUPT = -2147211232;
		public const HRESULT VDS_E_VOLUME_EXTEND_FVE_RECOVERY = -2147211231;
		public const HRESULT VDS_E_VOLUME_EXTEND_FVE = -2147211230;
		public const HRESULT VDS_E_SECTOR_SIZE_ERROR = -2147211229;
		public const HRESULT VDS_E_INITIATOR_ADAPTER_NOT_FOUND = -2147211008;
		public const HRESULT VDS_E_TARGET_PORTAL_NOT_FOUND = -2147211007;
		public const HRESULT VDS_E_INVALID_PORT_PATH = -2147211006;
		public const HRESULT VDS_E_INVALID_ISCSI_TARGET_NAME = -2147211005;
		public const HRESULT VDS_E_SET_TUNNEL_MODE_OUTER_ADDRESS = -2147211004;
		public const HRESULT VDS_E_ISCSI_GET_IKE_INFO = -2147211003;
		public const HRESULT VDS_E_ISCSI_SET_IKE_INFO = -2147211002;
		public const HRESULT VDS_E_SUBSYSTEM_ID_IS_NULL = -2147211001;
		public const HRESULT VDS_E_ISCSI_INITIATOR_NODE_NAME = -2147211000;
		public const HRESULT VDS_E_ISCSI_GROUP_PRESHARE_KEY = -2147210999;
		public const HRESULT VDS_E_ISCSI_CHAP_SECRET = -2147210998;
		public const HRESULT VDS_E_INVALID_IP_ADDRESS = -2147210997;
		public const HRESULT VDS_E_REBOOT_REQUIRED = -2147210996;
		public const HRESULT VDS_E_VOLUME_GUID_PATHNAME_NOT_ALLOWED = -2147210995;
		public const HRESULT VDS_E_BOOT_PAGEFILE_DRIVE_LETTER = -2147210994;
		public const HRESULT VDS_E_DELETE_WITH_CRITICAL = -2147210993;
		public const HRESULT VDS_E_CLEAN_WITH_DATA = -2147210992;
		public const HRESULT VDS_E_CLEAN_WITH_OEM = -2147210991;
		public const HRESULT VDS_E_CLEAN_WITH_CRITICAL = -2147210990;
		public const HRESULT VDS_E_FORMAT_CRITICAL = -2147210989;
		public const HRESULT VDS_E_NTFS_FORMAT_NOT_SUPPORTED = -2147210988;
		public const HRESULT VDS_E_FAT32_FORMAT_NOT_SUPPORTED = -2147210987;
		public const HRESULT VDS_E_FAT_FORMAT_NOT_SUPPORTED = -2147210986;
		public const HRESULT VDS_E_FORMAT_NOT_SUPPORTED = -2147210985;
		public const HRESULT VDS_E_COMPRESSION_NOT_SUPPORTED = -2147210984;
		public const HRESULT VDS_E_VDISK_NOT_OPEN = -2147210983;
		public const HRESULT VDS_E_VDISK_INVALID_OP_STATE = -2147210982;
		public const HRESULT VDS_E_INVALID_PATH = -2147210981;
		public const HRESULT VDS_E_INVALID_ISCSI_PATH = -2147210980;
		public const HRESULT VDS_E_SHRINK_LUN_NOT_UNMASKED = -2147210979;
		public const HRESULT VDS_E_LUN_DISK_READ_ONLY = -2147210978;
		public const HRESULT VDS_E_LUN_UPDATE_DISK = -2147210977;
		public const HRESULT VDS_E_LUN_DYNAMIC = -2147210976;
		public const HRESULT VDS_E_LUN_DYNAMIC_OFFLINE = -2147210975;
		public const HRESULT VDS_E_LUN_SHRINK_GPT_HEADER = -2147210974;
		public const HRESULT VDS_E_MIRROR_NOT_SUPPORTED = -2147210973;
		public const HRESULT VDS_E_RAID5_NOT_SUPPORTED = -2147210972;
		public const HRESULT VDS_E_DISK_NOT_CONVERTIBLE_SIZE = -2147210971;
		public const HRESULT VDS_E_OFFLINE_NOT_SUPPORTED = -2147210970;
		public const HRESULT VDS_E_VDISK_PATHNAME_INVALID = -2147210969;
		public const HRESULT VDS_E_EXTEND_TOO_MANY_CLUSTERS = -2147210968;
		public const HRESULT VDS_E_EXTEND_UNKNOWN_FILESYSTEM = -2147210967;
		public const HRESULT VDS_E_SHRINK_UNKNOWN_FILESYSTEM = -2147210966;
		public const HRESULT VDS_E_VD_DISK_NOT_OPEN = -2147210965;
		public const HRESULT VDS_E_VD_DISK_IS_EXPANDING = -2147210964;
		public const HRESULT VDS_E_VD_DISK_IS_COMPACTING = -2147210963;
		public const HRESULT VDS_E_VD_DISK_IS_MERGING = -2147210962;
		public const HRESULT VDS_E_VD_IS_ATTACHED = -2147210961;
		public const HRESULT VDS_E_VD_DISK_ALREADY_OPEN = -2147210960;
		public const HRESULT VDS_E_VD_DISK_ALREADY_EXPANDING = -2147210959;
		public const HRESULT VDS_E_VD_ALREADY_COMPACTING = -2147210958;
		public const HRESULT VDS_E_VD_ALREADY_MERGING = -2147210957;
		public const HRESULT VDS_E_VD_ALREADY_ATTACHED = -2147210956;
		public const HRESULT VDS_E_VD_ALREADY_DETACHED = -2147210955;
		public const HRESULT VDS_E_VD_NOT_ATTACHED_READONLY = -2147210954;
		public const HRESULT VDS_E_VD_IS_BEING_ATTACHED = -2147210953;
		public const HRESULT VDS_E_VD_IS_BEING_DETACHED = -2147210952;
		public const HRESULT VDS_E_NO_POOL = -2147210752;
		public const HRESULT VDS_E_NO_POOL_CREATED = -2147210751;
		public const HRESULT VDS_E_NO_MAINTENANCE_MODE = -2147210750;
		public const HRESULT VDS_E_BLOCK_CLUSTERED = -2147210749;
		public const HRESULT VDS_E_DISK_HAS_BANDS = -2147210748;
		public const HRESULT VDS_E_INVALID_STATE = -2147210747;
		public const HRESULT VDS_E_REFS_FORMAT_NOT_SUPPORTED = -2147210746;
		public const HRESULT VDS_E_DELETE_WITH_BOOTBACKING = -2147210745;
		public const HRESULT VDS_E_FORMAT_WITH_BOOTBACKING = -2147210744;
		public const HRESULT VDS_E_CLEAN_WITH_BOOTBACKING = -2147210743;
		public const HRESULT VDS_E_SHRINK_EXTEND_UNALIGNED = -2147210496;
		
		// --- Enums ---
		
		public enum VDS_NF_PACK : uint32
		{
			ARRIVE = 1,
			DEPART = 2,
			MODIFY = 3,
		}
		public enum VDS_NF_FILE_SYSTEM : uint32
		{
			MODIFY = 203,
			FORMAT_PROGRESS = 204,
		}
		public enum VDS_NF_CONTROLLER : uint32
		{
			ARRIVE = 103,
			DEPART = 104,
			MODIFY = 350,
			REMOVED = 351,
		}
		public enum VDS_NF_DRIVE : uint32
		{
			ARRIVE = 105,
			DEPART = 106,
			MODIFY = 107,
			REMOVED = 354,
		}
		public enum VDS_NF_PORT : uint32
		{
			ARRIVE = 121,
			DEPART = 122,
			MODIFY = 352,
			REMOVED = 353,
		}
		public enum VDS_NF_LUN : uint32
		{
			ARRIVE = 108,
			DEPART = 109,
			MODIFY = 110,
		}
		public enum VDS_NF_DISK : uint32
		{
			ARRIVE = 8,
			DEPART = 9,
			MODIFY = 10,
		}
		public enum VDS_STORAGE_IDENTIFIER_CODE_SET : int32
		{
			Reserved = 0,
			Binary = 1,
			Ascii = 2,
			Utf8 = 3,
		}
		public enum VDS_STORAGE_IDENTIFIER_TYPE : int32
		{
			VendorSpecific = 0,
			VendorId = 1,
			EUI64 = 2,
			FCPHName = 3,
			PortRelative = 4,
			TargetPortGroup = 5,
			LogicalUnitGroup = 6,
			MD5LogicalUnitIdentifier = 7,
			ScsiNameString = 8,
		}
		[AllowDuplicates]
		public enum VDS_STORAGE_BUS_TYPE : int32
		{
			TypeUnknown = 0,
			TypeScsi = 1,
			TypeAtapi = 2,
			TypeAta = 3,
			Type1394 = 4,
			TypeSsa = 5,
			TypeFibre = 6,
			TypeUsb = 7,
			TypeRAID = 8,
			TypeiScsi = 9,
			TypeSas = 10,
			TypeSata = 11,
			TypeSd = 12,
			TypeMmc = 13,
			TypeMax = 14,
			TypeVirtual = 14,
			TypeFileBackedVirtual = 15,
			TypeSpaces = 16,
			TypeNVMe = 17,
			TypeScm = 18,
			TypeUfs = 19,
			TypeMaxReserved = 127,
		}
		public enum VDS_INTERCONNECT_ADDRESS_TYPE : int32
		{
			UNKNOWN = 0,
			FCFS = 1,
			FCPH = 2,
			FCPH3 = 3,
			MAC = 4,
			SCSI = 5,
		}
		public enum VDS_OBJECT_TYPE : int32
		{
			UNKNOWN = 0,
			PROVIDER = 1,
			PACK = 10,
			VOLUME = 11,
			VOLUME_PLEX = 12,
			DISK = 13,
			SUB_SYSTEM = 30,
			CONTROLLER = 31,
			DRIVE = 32,
			LUN = 33,
			LUN_PLEX = 34,
			PORT = 35,
			PORTAL = 36,
			TARGET = 37,
			PORTAL_GROUP = 38,
			STORAGE_POOL = 39,
			HBAPORT = 90,
			INIT_ADAPTER = 91,
			INIT_PORTAL = 92,
			ASYNC = 100,
			ENUM = 101,
			VDISK = 200,
			OPEN_VDISK = 201,
		}
		public enum VDS_PROVIDER_TYPE : int32
		{
			UNKNOWN = 0,
			SOFTWARE = 1,
			HARDWARE = 2,
			VIRTUALDISK = 3,
			MAX = 4,
		}
		public enum VDS_PROVIDER_FLAG : int32
		{
			DYNAMIC = 1,
			INTERNAL_HARDWARE_PROVIDER = 2,
			ONE_DISK_ONLY_PER_PACK = 4,
			ONE_PACK_ONLINE_ONLY = 8,
			VOLUME_SPACE_MUST_BE_CONTIGUOUS = 16,
			SUPPORT_DYNAMIC = -2147483648,
			SUPPORT_FAULT_TOLERANT = 1073741824,
			SUPPORT_DYNAMIC_1394 = 536870912,
			SUPPORT_MIRROR = 32,
			SUPPORT_RAID5 = 64,
		}
		public enum VDS_RECOVER_ACTION : int32
		{
			UNKNOWN = 0,
			REFRESH = 1,
			RESTART = 2,
		}
		public enum VDS_NOTIFICATION_TARGET_TYPE : int32
		{
			UNKNOWN = 0,
			PACK = 10,
			VOLUME = 11,
			DISK = 13,
			PARTITION = 60,
			DRIVE_LETTER = 61,
			FILE_SYSTEM = 62,
			MOUNT_POINT = 63,
			SUB_SYSTEM = 30,
			CONTROLLER = 31,
			DRIVE = 32,
			LUN = 33,
			PORT = 35,
			PORTAL = 36,
			TARGET = 37,
			PORTAL_GROUP = 38,
			SERVICE = 200,
		}
		public enum VDS_ASYNC_OUTPUT_TYPE : int32
		{
			UNKNOWN = 0,
			CREATEVOLUME = 1,
			EXTENDVOLUME = 2,
			SHRINKVOLUME = 3,
			ADDVOLUMEPLEX = 4,
			BREAKVOLUMEPLEX = 5,
			REMOVEVOLUMEPLEX = 6,
			REPAIRVOLUMEPLEX = 7,
			RECOVERPACK = 8,
			REPLACEDISK = 9,
			CREATEPARTITION = 10,
			CLEAN = 11,
			CREATELUN = 50,
			ADDLUNPLEX = 52,
			REMOVELUNPLEX = 53,
			EXTENDLUN = 54,
			SHRINKLUN = 55,
			RECOVERLUN = 56,
			LOGINTOTARGET = 60,
			LOGOUTFROMTARGET = 61,
			CREATETARGET = 62,
			CREATEPORTALGROUP = 63,
			DELETETARGET = 64,
			ADDPORTAL = 65,
			REMOVEPORTAL = 66,
			DELETEPORTALGROUP = 67,
			FORMAT = 101,
			CREATE_VDISK = 200,
			ATTACH_VDISK = 201,
			COMPACT_VDISK = 202,
			MERGE_VDISK = 203,
			EXPAND_VDISK = 204,
		}
		public enum VDS_IPADDRESS_TYPE : int32
		{
			TEXT = 0,
			IPV4 = 1,
			IPV6 = 2,
			EMPTY = 3,
		}
		public enum VDS_HEALTH : int32
		{
			UNKNOWN = 0,
			HEALTHY = 1,
			REBUILDING = 2,
			STALE = 3,
			FAILING = 4,
			FAILING_REDUNDANCY = 5,
			FAILED_REDUNDANCY = 6,
			FAILED_REDUNDANCY_FAILING = 7,
			FAILED = 8,
			REPLACED = 9,
			PENDING_FAILURE = 10,
			DEGRADED = 11,
		}
		public enum VDS_TRANSITION_STATE : int32
		{
			UNKNOWN = 0,
			STABLE = 1,
			EXTENDING = 2,
			SHRINKING = 3,
			RECONFIGING = 4,
			RESTRIPING = 5,
		}
		public enum VDS_FILE_SYSTEM_TYPE : int32
		{
			UNKNOWN = 0,
			RAW = 1,
			FAT = 2,
			FAT32 = 3,
			NTFS = 4,
			CDFS = 5,
			UDF = 6,
			EXFAT = 7,
			CSVFS = 8,
			REFS = 9,
		}
		public enum VDS_HBAPORT_TYPE : int32
		{
			UNKNOWN = 1,
			OTHER = 2,
			NOTPRESENT = 3,
			NPORT = 5,
			NLPORT = 6,
			FLPORT = 7,
			FPORT = 8,
			EPORT = 9,
			GPORT = 10,
			LPORT = 20,
			PTP = 21,
		}
		public enum VDS_HBAPORT_STATUS : int32
		{
			UNKNOWN = 1,
			ONLINE = 2,
			OFFLINE = 3,
			BYPASSED = 4,
			DIAGNOSTICS = 5,
			LINKDOWN = 6,
			ERROR = 7,
			LOOPBACK = 8,
		}
		public enum VDS_HBAPORT_SPEED_FLAG : int32
		{
			UNKNOWN = 0,
			_1GBIT = 1,
			_2GBIT = 2,
			_10GBIT = 4,
			_4GBIT = 8,
			NOT_NEGOTIATED = 32768,
		}
		public enum VDS_PATH_STATUS : int32
		{
			UNKNOWN = 0,
			ONLINE = 1,
			FAILED = 5,
			STANDBY = 7,
		}
		public enum VDS_LOADBALANCE_POLICY_ENUM : int32
		{
			UNKNOWN = 0,
			FAILOVER = 1,
			ROUND_ROBIN = 2,
			ROUND_ROBIN_WITH_SUBSET = 3,
			DYN_LEAST_QUEUE_DEPTH = 4,
			WEIGHTED_PATHS = 5,
			LEAST_BLOCKS = 6,
			VENDOR_SPECIFIC = 7,
		}
		public enum VDS_PROVIDER_LBSUPPORT_FLAG : int32
		{
			FAILOVER = 1,
			ROUND_ROBIN = 2,
			ROUND_ROBIN_WITH_SUBSET = 4,
			DYN_LEAST_QUEUE_DEPTH = 8,
			WEIGHTED_PATHS = 16,
			LEAST_BLOCKS = 32,
			VENDOR_SPECIFIC = 64,
		}
		public enum VDS_VERSION_SUPPORT_FLAG : int32
		{
			_1_0 = 1,
			_1_1 = 2,
			_2_0 = 4,
			_2_1 = 8,
			_3_0 = 16,
		}
		public enum VDS_HWPROVIDER_TYPE : int32
		{
			UNKNOWN = 0,
			PCI_RAID = 1,
			FIBRE_CHANNEL = 2,
			ISCSI = 3,
			SAS = 4,
			HYBRID = 5,
		}
		public enum VDS_ISCSI_LOGIN_TYPE : int32
		{
			MANUAL = 0,
			PERSISTENT = 1,
			BOOT = 2,
		}
		public enum VDS_ISCSI_AUTH_TYPE : int32
		{
			NONE = 0,
			CHAP = 1,
			MUTUAL_CHAP = 2,
		}
		public enum VDS_ISCSI_IPSEC_FLAG : int32
		{
			VALID = 1,
			IKE = 2,
			MAIN_MODE = 4,
			AGGRESSIVE_MODE = 8,
			PFS_ENABLE = 16,
			TRANSPORT_MODE_PREFERRED = 32,
			TUNNEL_MODE_PREFERRED = 64,
		}
		public enum VDS_ISCSI_LOGIN_FLAG : int32
		{
			REQUIRE_IPSEC = 1,
			MULTIPATH_ENABLED = 2,
		}
		public enum VDS_SUB_SYSTEM_STATUS : int32
		{
			UNKNOWN = 0,
			ONLINE = 1,
			NOT_READY = 2,
			OFFLINE = 4,
			FAILED = 5,
			PARTIALLY_MANAGED = 9,
		}
		public enum VDS_SUB_SYSTEM_FLAG : int32
		{
			LUN_MASKING_CAPABLE = 1,
			LUN_PLEXING_CAPABLE = 2,
			LUN_REMAPPING_CAPABLE = 4,
			DRIVE_EXTENT_CAPABLE = 8,
			HARDWARE_CHECKSUM_CAPABLE = 16,
			RADIUS_CAPABLE = 32,
			READ_BACK_VERIFY_CAPABLE = 64,
			WRITE_THROUGH_CACHING_CAPABLE = 128,
			SUPPORTS_FAULT_TOLERANT_LUNS = 512,
			SUPPORTS_NON_FAULT_TOLERANT_LUNS = 1024,
			SUPPORTS_SIMPLE_LUNS = 2048,
			SUPPORTS_SPAN_LUNS = 4096,
			SUPPORTS_STRIPE_LUNS = 8192,
			SUPPORTS_MIRROR_LUNS = 16384,
			SUPPORTS_PARITY_LUNS = 32768,
			SUPPORTS_AUTH_CHAP = 65536,
			SUPPORTS_AUTH_MUTUAL_CHAP = 131072,
			SUPPORTS_SIMPLE_TARGET_CONFIG = 262144,
			SUPPORTS_LUN_NUMBER = 524288,
			SUPPORTS_MIRRORED_CACHE = 1048576,
			READ_CACHING_CAPABLE = 2097152,
			WRITE_CACHING_CAPABLE = 4194304,
			MEDIA_SCAN_CAPABLE = 8388608,
			CONSISTENCY_CHECK_CAPABLE = 16777216,
		}
		public enum VDS_SUB_SYSTEM_SUPPORTED_RAID_TYPE_FLAG : int32
		{
			RAID2_LUNS = 1,
			RAID3_LUNS = 2,
			RAID4_LUNS = 4,
			RAID5_LUNS = 8,
			RAID6_LUNS = 16,
			RAID01_LUNS = 32,
			RAID03_LUNS = 64,
			RAID05_LUNS = 128,
			RAID10_LUNS = 256,
			RAID15_LUNS = 512,
			RAID30_LUNS = 1024,
			RAID50_LUNS = 2048,
			RAID51_LUNS = 4096,
			RAID53_LUNS = 8192,
			RAID60_LUNS = 16384,
			RAID61_LUNS = 32768,
		}
		public enum VDS_INTERCONNECT_FLAG : int32
		{
			PCI_RAID = 1,
			FIBRE_CHANNEL = 2,
			ISCSI = 4,
			SAS = 8,
		}
		public enum VDS_CONTROLLER_STATUS : int32
		{
			UNKNOWN = 0,
			ONLINE = 1,
			NOT_READY = 2,
			OFFLINE = 4,
			FAILED = 5,
			REMOVED = 8,
		}
		public enum VDS_PORT_STATUS : int32
		{
			UNKNOWN = 0,
			ONLINE = 1,
			NOT_READY = 2,
			OFFLINE = 4,
			FAILED = 5,
			REMOVED = 8,
		}
		public enum VDS_DRIVE_STATUS : int32
		{
			UNKNOWN = 0,
			ONLINE = 1,
			NOT_READY = 2,
			OFFLINE = 4,
			FAILED = 5,
			REMOVED = 8,
		}
		public enum VDS_DRIVE_FLAG : int32
		{
			HOTSPARE = 1,
			ASSIGNED = 2,
			UNASSIGNED = 4,
			HOTSPARE_IN_USE = 8,
			HOTSPARE_STANDBY = 16,
		}
		public enum VDS_LUN_TYPE : int32
		{
			UNKNOWN = 0,
			DEFAULT = 1,
			FAULT_TOLERANT = 2,
			NON_FAULT_TOLERANT = 3,
			SIMPLE = 10,
			SPAN = 11,
			STRIPE = 12,
			MIRROR = 13,
			PARITY = 14,
			RAID2 = 15,
			RAID3 = 16,
			RAID4 = 17,
			RAID5 = 18,
			RAID6 = 19,
			RAID01 = 20,
			RAID03 = 21,
			RAID05 = 22,
			RAID10 = 23,
			RAID15 = 24,
			RAID30 = 25,
			RAID50 = 26,
			RAID51 = 27,
			RAID53 = 28,
			RAID60 = 29,
			RAID61 = 30,
		}
		public enum VDS_LUN_STATUS : int32
		{
			UNKNOWN = 0,
			ONLINE = 1,
			NOT_READY = 2,
			OFFLINE = 4,
			FAILED = 5,
		}
		public enum VDS_LUN_FLAG : int32
		{
			LBN_REMAP_ENABLED = 1,
			READ_BACK_VERIFY_ENABLED = 2,
			WRITE_THROUGH_CACHING_ENABLED = 4,
			HARDWARE_CHECKSUM_ENABLED = 8,
			READ_CACHE_ENABLED = 16,
			WRITE_CACHE_ENABLED = 32,
			MEDIA_SCAN_ENABLED = 64,
			CONSISTENCY_CHECK_ENABLED = 128,
			SNAPSHOT = 256,
		}
		public enum VDS_LUN_PLEX_TYPE : int32
		{
			UNKNOWN = 0,
			SIMPLE = 10,
			SPAN = 11,
			STRIPE = 12,
			PARITY = 14,
			RAID2 = 15,
			RAID3 = 16,
			RAID4 = 17,
			RAID5 = 18,
			RAID6 = 19,
			RAID03 = 21,
			RAID05 = 22,
			RAID10 = 23,
			RAID15 = 24,
			RAID30 = 25,
			RAID50 = 26,
			RAID53 = 28,
			RAID60 = 29,
		}
		public enum VDS_LUN_PLEX_STATUS : int32
		{
			UNKNOWN = 0,
			ONLINE = 1,
			NOT_READY = 2,
			OFFLINE = 4,
			FAILED = 5,
		}
		public enum VDS_LUN_PLEX_FLAG : int32
		{
			LPF_LBN_REMAP_ENABLED = 1,
		}
		public enum VDS_ISCSI_PORTAL_STATUS : int32
		{
			UNKNOWN = 0,
			ONLINE = 1,
			NOT_READY = 2,
			OFFLINE = 4,
			FAILED = 5,
		}
		public enum VDS_STORAGE_POOL_STATUS : int32
		{
			UNKNOWN = 0,
			ONLINE = 1,
			NOT_READY = 2,
			OFFLINE = 4,
		}
		public enum VDS_STORAGE_POOL_TYPE : int32
		{
			UNKNOWN = 0,
			PRIMORDIAL = 1,
			CONCRETE = 2,
		}
		public enum VDS_MAINTENANCE_OPERATION : int32
		{
			BlinkLight = 1,
			BeepAlarm = 2,
			SpinDown = 3,
			SpinUp = 4,
			Ping = 5,
		}
		public enum VDS_RAID_TYPE : int32
		{
			UNKNOWN = 0,
			RAID0 = 10,
			RAID1 = 11,
			RAID2 = 12,
			RAID3 = 13,
			RAID4 = 14,
			RAID5 = 15,
			RAID6 = 16,
			RAID01 = 17,
			RAID03 = 18,
			RAID05 = 19,
			RAID10 = 20,
			RAID15 = 21,
			RAID30 = 22,
			RAID50 = 23,
			RAID51 = 24,
			RAID53 = 25,
			RAID60 = 26,
			RAID61 = 27,
		}
		
		// --- Structs ---
		
		[CRepr]
		public struct VDS_STORAGE_IDENTIFIER
		{
			public VDS_STORAGE_IDENTIFIER_CODE_SET m_CodeSet;
			public VDS_STORAGE_IDENTIFIER_TYPE m_Type;
			public uint32 m_cbIdentifier;
			public uint8* m_rgbIdentifier;
		}
		[CRepr]
		public struct VDS_STORAGE_DEVICE_ID_DESCRIPTOR
		{
			public uint32 m_version;
			public uint32 m_cIdentifiers;
			public VDS_STORAGE_IDENTIFIER* m_rgIdentifiers;
		}
		[CRepr]
		public struct VDS_INTERCONNECT
		{
			public VDS_INTERCONNECT_ADDRESS_TYPE m_addressType;
			public uint32 m_cbPort;
			public uint8* m_pbPort;
			public uint32 m_cbAddress;
			public uint8* m_pbAddress;
		}
		[CRepr]
		public struct VDS_LUN_INFORMATION
		{
			public uint32 m_version;
			public uint8 m_DeviceType;
			public uint8 m_DeviceTypeModifier;
			public BOOL m_bCommandQueueing;
			public VDS_STORAGE_BUS_TYPE m_BusType;
			public uint8* m_szVendorId;
			public uint8* m_szProductId;
			public uint8* m_szProductRevision;
			public uint8* m_szSerialNumber;
			public Guid m_diskSignature;
			public VDS_STORAGE_DEVICE_ID_DESCRIPTOR m_deviceIdDescriptor;
			public uint32 m_cInterconnects;
			public VDS_INTERCONNECT* m_rgInterconnects;
		}
		[CRepr]
		public struct VDS_PACK_NOTIFICATION
		{
			public VDS_NF_PACK ulEvent;
			public Guid packId;
		}
		[CRepr]
		public struct VDS_DISK_NOTIFICATION
		{
			public VDS_NF_DISK ulEvent;
			public Guid diskId;
		}
		[CRepr]
		public struct VDS_VOLUME_NOTIFICATION
		{
			public uint32 ulEvent;
			public Guid volumeId;
			public Guid plexId;
			public uint32 ulPercentCompleted;
		}
		[CRepr]
		public struct VDS_PARTITION_NOTIFICATION
		{
			public uint32 ulEvent;
			public Guid diskId;
			public uint64 ullOffset;
		}
		[CRepr]
		public struct VDS_SERVICE_NOTIFICATION
		{
			public uint32 ulEvent;
			public VDS_RECOVER_ACTION action;
		}
		[CRepr]
		public struct VDS_DRIVE_LETTER_NOTIFICATION
		{
			public uint32 ulEvent;
			public char16 wcLetter;
			public Guid volumeId;
		}
		[CRepr]
		public struct VDS_FILE_SYSTEM_NOTIFICATION
		{
			public VDS_NF_FILE_SYSTEM ulEvent;
			public Guid volumeId;
			public uint32 dwPercentCompleted;
		}
		[CRepr]
		public struct VDS_MOUNT_POINT_NOTIFICATION
		{
			public uint32 ulEvent;
			public Guid volumeId;
		}
		[CRepr]
		public struct VDS_SUB_SYSTEM_NOTIFICATION
		{
			public uint32 ulEvent;
			public Guid subSystemId;
		}
		[CRepr]
		public struct VDS_CONTROLLER_NOTIFICATION
		{
			public VDS_NF_CONTROLLER ulEvent;
			public Guid controllerId;
		}
		[CRepr]
		public struct VDS_DRIVE_NOTIFICATION
		{
			public VDS_NF_DRIVE ulEvent;
			public Guid driveId;
		}
		[CRepr]
		public struct VDS_LUN_NOTIFICATION
		{
			public VDS_NF_LUN ulEvent;
			public Guid LunId;
		}
		[CRepr]
		public struct VDS_PORT_NOTIFICATION
		{
			public VDS_NF_PORT ulEvent;
			public Guid portId;
		}
		[CRepr]
		public struct VDS_PORTAL_NOTIFICATION
		{
			public uint32 ulEvent;
			public Guid portalId;
		}
		[CRepr]
		public struct VDS_TARGET_NOTIFICATION
		{
			public uint32 ulEvent;
			public Guid targetId;
		}
		[CRepr]
		public struct VDS_PORTAL_GROUP_NOTIFICATION
		{
			public uint32 ulEvent;
			public Guid portalGroupId;
		}
		[CRepr]
		public struct VDS_NOTIFICATION
		{
			public VDS_NOTIFICATION_TARGET_TYPE objectType;
			public _Anonymous_e__Union Anonymous;
			
			[CRepr, Union]
			public struct _Anonymous_e__Union
			{
				public VDS_PACK_NOTIFICATION Pack;
				public VDS_DISK_NOTIFICATION Disk;
				public VDS_VOLUME_NOTIFICATION Volume;
				public VDS_PARTITION_NOTIFICATION Partition;
				public VDS_DRIVE_LETTER_NOTIFICATION Letter;
				public VDS_FILE_SYSTEM_NOTIFICATION FileSystem;
				public VDS_MOUNT_POINT_NOTIFICATION MountPoint;
				public VDS_SUB_SYSTEM_NOTIFICATION SubSystem;
				public VDS_CONTROLLER_NOTIFICATION Controller;
				public VDS_DRIVE_NOTIFICATION Drive;
				public VDS_LUN_NOTIFICATION Lun;
				public VDS_PORT_NOTIFICATION Port;
				public VDS_PORTAL_NOTIFICATION Portal;
				public VDS_TARGET_NOTIFICATION Target;
				public VDS_PORTAL_GROUP_NOTIFICATION PortalGroup;
				public VDS_SERVICE_NOTIFICATION Service;
			}
		}
		[CRepr]
		public struct VDS_ASYNC_OUTPUT
		{
			public VDS_ASYNC_OUTPUT_TYPE type;
			public _Anonymous_e__Union Anonymous;
			
			[CRepr, Union]
			public struct _Anonymous_e__Union
			{
				public _cp cp;
				public _cv cv;
				public _bvp bvp;
				public _sv sv;
				public _cl cl;
				public _ct ct;
				public _cpg cpg;
				public _cvd cvd;
				
				[CRepr]
				public struct _cpg
				{
					public IUnknown* pPortalGroupUnk;
				}
				[CRepr]
				public struct _cl
				{
					public IUnknown* pLunUnk;
				}
				[CRepr]
				public struct _bvp
				{
					public IUnknown* pVolumeUnk;
				}
				[CRepr]
				public struct _cp
				{
					public uint64 ullOffset;
					public Guid volumeId;
				}
				[CRepr]
				public struct _cvd
				{
					public IUnknown* pVDiskUnk;
				}
				[CRepr]
				public struct _sv
				{
					public uint64 ullReclaimedBytes;
				}
				[CRepr]
				public struct _ct
				{
					public IUnknown* pTargetUnk;
				}
				[CRepr]
				public struct _cv
				{
					public IUnknown* pVolumeUnk;
				}
			}
		}
		[CRepr]
		public struct VDS_PATH_ID
		{
			public uint64 ullSourceId;
			public uint64 ullPathId;
		}
		[CRepr]
		public struct VDS_WWN
		{
			public uint8[8] rguchWwn;
		}
		[CRepr]
		public struct VDS_IPADDRESS
		{
			public VDS_IPADDRESS_TYPE type;
			public uint32 ipv4Address;
			public uint8[16] ipv6Address;
			public uint32 ulIpv6FlowInfo;
			public uint32 ulIpv6ScopeId;
			public char16[257] wszTextAddress;
			public uint32 ulPort;
		}
		[CRepr]
		public struct VDS_ISCSI_IPSEC_KEY
		{
			public uint8* pKey;
			public uint32 ulKeySize;
		}
		[CRepr]
		public struct VDS_ISCSI_SHARED_SECRET
		{
			public uint8* pSharedSecret;
			public uint32 ulSharedSecretSize;
		}
		[CRepr]
		public struct VDS_HBAPORT_PROP
		{
			public Guid id;
			public VDS_WWN wwnNode;
			public VDS_WWN wwnPort;
			public VDS_HBAPORT_TYPE type;
			public VDS_HBAPORT_STATUS status;
			public uint32 ulPortSpeed;
			public uint32 ulSupportedPortSpeed;
		}
		[CRepr]
		public struct VDS_ISCSI_INITIATOR_ADAPTER_PROP
		{
			public Guid id;
			public PWSTR pwszName;
		}
		[CRepr]
		public struct VDS_ISCSI_INITIATOR_PORTAL_PROP
		{
			public Guid id;
			public VDS_IPADDRESS address;
			public uint32 ulPortIndex;
		}
		[CRepr]
		public struct VDS_PROVIDER_PROP
		{
			public Guid id;
			public PWSTR pwszName;
			public Guid guidVersionId;
			public PWSTR pwszVersion;
			public VDS_PROVIDER_TYPE type;
			public uint32 ulFlags;
			public uint32 ulStripeSizeFlags;
			public int16 sRebuildPriority;
		}
		[CRepr]
		public struct VDS_PATH_INFO
		{
			public VDS_PATH_ID pathId;
			public VDS_HWPROVIDER_TYPE type;
			public VDS_PATH_STATUS status;
			public _Anonymous1_e__Union Anonymous1;
			public _Anonymous2_e__Union Anonymous2;
			public _Anonymous3_e__Union Anonymous3;
			
			[CRepr, Union]
			public struct _Anonymous2_e__Union
			{
				public Guid hbaPortId;
				public Guid initiatorAdapterId;
			}
			[CRepr, Union]
			public struct _Anonymous1_e__Union
			{
				public Guid controllerPortId;
				public Guid targetPortalId;
			}
			[CRepr, Union]
			public struct _Anonymous3_e__Union
			{
				public VDS_HBAPORT_PROP* pHbaPortProp;
				public VDS_IPADDRESS* pInitiatorPortalIpAddr;
			}
		}
		[CRepr]
		public struct VDS_PATH_POLICY
		{
			public VDS_PATH_ID pathId;
			public BOOL bPrimaryPath;
			public uint32 ulWeight;
		}
		[CRepr]
		public struct VDS_HINTS
		{
			public uint64 ullHintMask;
			public uint64 ullExpectedMaximumSize;
			public uint32 ulOptimalReadSize;
			public uint32 ulOptimalReadAlignment;
			public uint32 ulOptimalWriteSize;
			public uint32 ulOptimalWriteAlignment;
			public uint32 ulMaximumDriveCount;
			public uint32 ulStripeSize;
			public BOOL bFastCrashRecoveryRequired;
			public BOOL bMostlyReads;
			public BOOL bOptimizeForSequentialReads;
			public BOOL bOptimizeForSequentialWrites;
			public BOOL bRemapEnabled;
			public BOOL bReadBackVerifyEnabled;
			public BOOL bWriteThroughCachingEnabled;
			public BOOL bHardwareChecksumEnabled;
			public BOOL bIsYankable;
			public int16 sRebuildPriority;
		}
		[CRepr]
		public struct VDS_HINTS2
		{
			public uint64 ullHintMask;
			public uint64 ullExpectedMaximumSize;
			public uint32 ulOptimalReadSize;
			public uint32 ulOptimalReadAlignment;
			public uint32 ulOptimalWriteSize;
			public uint32 ulOptimalWriteAlignment;
			public uint32 ulMaximumDriveCount;
			public uint32 ulStripeSize;
			public uint32 ulReserved1;
			public uint32 ulReserved2;
			public uint32 ulReserved3;
			public BOOL bFastCrashRecoveryRequired;
			public BOOL bMostlyReads;
			public BOOL bOptimizeForSequentialReads;
			public BOOL bOptimizeForSequentialWrites;
			public BOOL bRemapEnabled;
			public BOOL bReadBackVerifyEnabled;
			public BOOL bWriteThroughCachingEnabled;
			public BOOL bHardwareChecksumEnabled;
			public BOOL bIsYankable;
			public BOOL bAllocateHotSpare;
			public BOOL bUseMirroredCache;
			public BOOL bReadCachingEnabled;
			public BOOL bWriteCachingEnabled;
			public BOOL bMediaScanEnabled;
			public BOOL bConsistencyCheckEnabled;
			public VDS_STORAGE_BUS_TYPE BusType;
			public BOOL bReserved1;
			public BOOL bReserved2;
			public BOOL bReserved3;
			public int16 sRebuildPriority;
		}
		[CRepr]
		public struct VDS_SUB_SYSTEM_PROP
		{
			public Guid id;
			public PWSTR pwszFriendlyName;
			public PWSTR pwszIdentification;
			public uint32 ulFlags;
			public uint32 ulStripeSizeFlags;
			public VDS_SUB_SYSTEM_STATUS status;
			public VDS_HEALTH health;
			public int16 sNumberOfInternalBuses;
			public int16 sMaxNumberOfSlotsEachBus;
			public int16 sMaxNumberOfControllers;
			public int16 sRebuildPriority;
		}
		[CRepr]
		public struct VDS_SUB_SYSTEM_PROP2
		{
			public Guid id;
			public PWSTR pwszFriendlyName;
			public PWSTR pwszIdentification;
			public uint32 ulFlags;
			public uint32 ulStripeSizeFlags;
			public uint32 ulSupportedRaidTypeFlags;
			public VDS_SUB_SYSTEM_STATUS status;
			public VDS_HEALTH health;
			public int16 sNumberOfInternalBuses;
			public int16 sMaxNumberOfSlotsEachBus;
			public int16 sMaxNumberOfControllers;
			public int16 sRebuildPriority;
			public uint32 ulNumberOfEnclosures;
		}
		[CRepr]
		public struct VDS_CONTROLLER_PROP
		{
			public Guid id;
			public PWSTR pwszFriendlyName;
			public PWSTR pwszIdentification;
			public VDS_CONTROLLER_STATUS status;
			public VDS_HEALTH health;
			public int16 sNumberOfPorts;
		}
		[CRepr]
		public struct VDS_DRIVE_PROP
		{
			public Guid id;
			public uint64 ullSize;
			public PWSTR pwszFriendlyName;
			public PWSTR pwszIdentification;
			public uint32 ulFlags;
			public VDS_DRIVE_STATUS status;
			public VDS_HEALTH health;
			public int16 sInternalBusNumber;
			public int16 sSlotNumber;
		}
		[CRepr]
		public struct VDS_DRIVE_PROP2
		{
			public Guid id;
			public uint64 ullSize;
			public PWSTR pwszFriendlyName;
			public PWSTR pwszIdentification;
			public uint32 ulFlags;
			public VDS_DRIVE_STATUS status;
			public VDS_HEALTH health;
			public int16 sInternalBusNumber;
			public int16 sSlotNumber;
			public uint32 ulEnclosureNumber;
			public VDS_STORAGE_BUS_TYPE busType;
			public uint32 ulSpindleSpeed;
		}
		[CRepr]
		public struct VDS_DRIVE_EXTENT
		{
			public Guid id;
			public Guid LunId;
			public uint64 ullSize;
			public BOOL bUsed;
		}
		[CRepr]
		public struct VDS_LUN_PROP
		{
			public Guid id;
			public uint64 ullSize;
			public PWSTR pwszFriendlyName;
			public PWSTR pwszIdentification;
			public PWSTR pwszUnmaskingList;
			public uint32 ulFlags;
			public VDS_LUN_TYPE type;
			public VDS_LUN_STATUS status;
			public VDS_HEALTH health;
			public VDS_TRANSITION_STATE TransitionState;
			public int16 sRebuildPriority;
		}
		[CRepr]
		public struct VDS_LUN_PLEX_PROP
		{
			public Guid id;
			public uint64 ullSize;
			public VDS_LUN_PLEX_TYPE type;
			public VDS_LUN_PLEX_STATUS status;
			public VDS_HEALTH health;
			public VDS_TRANSITION_STATE TransitionState;
			public uint32 ulFlags;
			public uint32 ulStripeSize;
			public int16 sRebuildPriority;
		}
		[CRepr]
		public struct VDS_PORT_PROP
		{
			public Guid id;
			public PWSTR pwszFriendlyName;
			public PWSTR pwszIdentification;
			public VDS_PORT_STATUS status;
		}
		[CRepr]
		public struct VDS_ISCSI_PORTAL_PROP
		{
			public Guid id;
			public VDS_IPADDRESS address;
			public VDS_ISCSI_PORTAL_STATUS status;
		}
		[CRepr]
		public struct VDS_ISCSI_TARGET_PROP
		{
			public Guid id;
			public PWSTR pwszIscsiName;
			public PWSTR pwszFriendlyName;
			public BOOL bChapEnabled;
		}
		[CRepr]
		public struct VDS_ISCSI_PORTALGROUP_PROP
		{
			public Guid id;
			public uint16 tag;
		}
		[CRepr]
		public struct VDS_POOL_CUSTOM_ATTRIBUTES
		{
			public PWSTR pwszName;
			public PWSTR pwszValue;
		}
		[CRepr]
		public struct VDS_POOL_ATTRIBUTES
		{
			public uint64 ullAttributeMask;
			public VDS_RAID_TYPE raidType;
			public VDS_STORAGE_BUS_TYPE busType;
			public PWSTR pwszIntendedUsage;
			public BOOL bSpinDown;
			public BOOL bIsThinProvisioned;
			public uint64 ullProvisionedSpace;
			public BOOL bNoSinglePointOfFailure;
			public uint32 ulDataRedundancyMax;
			public uint32 ulDataRedundancyMin;
			public uint32 ulDataRedundancyDefault;
			public uint32 ulPackageRedundancyMax;
			public uint32 ulPackageRedundancyMin;
			public uint32 ulPackageRedundancyDefault;
			public uint32 ulStripeSize;
			public uint32 ulStripeSizeMax;
			public uint32 ulStripeSizeMin;
			public uint32 ulDefaultStripeSize;
			public uint32 ulNumberOfColumns;
			public uint32 ulNumberOfColumnsMax;
			public uint32 ulNumberOfColumnsMin;
			public uint32 ulDefaultNumberofColumns;
			public uint32 ulDataAvailabilityHint;
			public uint32 ulAccessRandomnessHint;
			public uint32 ulAccessDirectionHint;
			public uint32 ulAccessSizeHint;
			public uint32 ulAccessLatencyHint;
			public uint32 ulAccessBandwidthWeightHint;
			public uint32 ulStorageCostHint;
			public uint32 ulStorageEfficiencyHint;
			public uint32 ulNumOfCustomAttributes;
			public VDS_POOL_CUSTOM_ATTRIBUTES* pPoolCustomAttributes;
			public BOOL bReserved1;
			public BOOL bReserved2;
			public uint32 ulReserved1;
			public uint32 ulReserved2;
			public uint64 ullReserved1;
			public uint64 ullReserved2;
		}
		[CRepr]
		public struct VDS_STORAGE_POOL_PROP
		{
			public Guid id;
			public VDS_STORAGE_POOL_STATUS status;
			public VDS_HEALTH health;
			public VDS_STORAGE_POOL_TYPE type;
			public PWSTR pwszName;
			public PWSTR pwszDescription;
			public uint64 ullTotalConsumedSpace;
			public uint64 ullTotalManagedSpace;
			public uint64 ullRemainingFreeSpace;
		}
		[CRepr]
		public struct VDS_STORAGE_POOL_DRIVE_EXTENT
		{
			public Guid id;
			public uint64 ullSize;
			public BOOL bUsed;
		}
		
		// --- COM Interfaces ---
		
		[CRepr]
		public struct IEnumVdsObject : IUnknown
		{
			public const new Guid IID = .(0x118610b7, 0x8d94, 0x4030, 0xb5, 0xb8, 0x50, 0x08, 0x89, 0x78, 0x8e, 0x4e);
			
			public new VTable* VT { get => (.)vt; }
			
			public HRESULT Next(uint32 celt, IUnknown** ppObjectArray, out uint32 pcFetched) mut => VT.Next(ref this, celt, ppObjectArray, out pcFetched);
			public HRESULT Skip(uint32 celt) mut => VT.Skip(ref this, celt);
			public HRESULT Reset() mut => VT.Reset(ref this);
			public HRESULT Clone(IEnumVdsObject** ppEnum) mut => VT.Clone(ref this, ppEnum);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IEnumVdsObject self, uint32 celt, IUnknown** ppObjectArray, out uint32 pcFetched) Next;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IEnumVdsObject self, uint32 celt) Skip;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IEnumVdsObject self) Reset;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IEnumVdsObject self, IEnumVdsObject** ppEnum) Clone;
			}
		}
		[CRepr]
		public struct IVdsAsync : IUnknown
		{
			public const new Guid IID = .(0xd5d23b6d, 0x5a55, 0x4492, 0x98, 0x89, 0x39, 0x7a, 0x3c, 0x2d, 0x2d, 0xbc);
			
			public new VTable* VT { get => (.)vt; }
			
			public HRESULT Cancel() mut => VT.Cancel(ref this);
			public HRESULT Wait(out HRESULT pHrResult, out VDS_ASYNC_OUTPUT pAsyncOut) mut => VT.Wait(ref this, out pHrResult, out pAsyncOut);
			public HRESULT QueryStatus(out HRESULT pHrResult, out uint32 pulPercentCompleted) mut => VT.QueryStatus(ref this, out pHrResult, out pulPercentCompleted);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsAsync self) Cancel;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsAsync self, out HRESULT pHrResult, out VDS_ASYNC_OUTPUT pAsyncOut) Wait;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsAsync self, out HRESULT pHrResult, out uint32 pulPercentCompleted) QueryStatus;
			}
		}
		[CRepr]
		public struct IVdsAdviseSink : IUnknown
		{
			public const new Guid IID = .(0x8326cd1d, 0xcf59, 0x4936, 0xb7, 0x86, 0x5e, 0xfc, 0x08, 0x79, 0x8e, 0x25);
			
			public new VTable* VT { get => (.)vt; }
			
			public HRESULT OnNotify(int32 lNumberOfNotifications, VDS_NOTIFICATION* pNotificationArray) mut => VT.OnNotify(ref this, lNumberOfNotifications, pNotificationArray);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsAdviseSink self, int32 lNumberOfNotifications, VDS_NOTIFICATION* pNotificationArray) OnNotify;
			}
		}
		[CRepr]
		public struct IVdsProvider : IUnknown
		{
			public const new Guid IID = .(0x10c5e575, 0x7984, 0x4e81, 0xa5, 0x6b, 0x43, 0x1f, 0x5f, 0x92, 0xae, 0x42);
			
			public new VTable* VT { get => (.)vt; }
			
			public HRESULT GetProperties(out VDS_PROVIDER_PROP pProviderProp) mut => VT.GetProperties(ref this, out pProviderProp);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsProvider self, out VDS_PROVIDER_PROP pProviderProp) GetProperties;
			}
		}
		[CRepr]
		public struct IVdsProviderSupport : IUnknown
		{
			public const new Guid IID = .(0x1732be13, 0xe8f9, 0x4a03, 0xbf, 0xbc, 0x5f, 0x61, 0x6a, 0xa6, 0x6c, 0xe1);
			
			public new VTable* VT { get => (.)vt; }
			
			public HRESULT GetVersionSupport(out uint32 ulVersionSupport) mut => VT.GetVersionSupport(ref this, out ulVersionSupport);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsProviderSupport self, out uint32 ulVersionSupport) GetVersionSupport;
			}
		}
		[CRepr]
		public struct IVdsProviderPrivate : IUnknown
		{
			public const new Guid IID = .(0x11f3cd41, 0xb7e8, 0x48ff, 0x94, 0x72, 0x9d, 0xff, 0x01, 0x8a, 0xa2, 0x92);
			
			public new VTable* VT { get => (.)vt; }
			
			public HRESULT GetObject(Guid ObjectId, VDS_OBJECT_TYPE type, IUnknown** ppObjectUnk) mut => VT.GetObject(ref this, ObjectId, type, ppObjectUnk);
			public HRESULT OnLoad(PWSTR pwszMachineName, IUnknown* pCallbackObject) mut => VT.OnLoad(ref this, pwszMachineName, pCallbackObject);
			public HRESULT OnUnload(BOOL bForceUnload) mut => VT.OnUnload(ref this, bForceUnload);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsProviderPrivate self, Guid ObjectId, VDS_OBJECT_TYPE type, IUnknown** ppObjectUnk) GetObject;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsProviderPrivate self, PWSTR pwszMachineName, IUnknown* pCallbackObject) OnLoad;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsProviderPrivate self, BOOL bForceUnload) OnUnload;
			}
		}
		[CRepr]
		public struct IVdsHwProvider : IUnknown
		{
			public const new Guid IID = .(0xd99bdaae, 0xb13a, 0x4178, 0x9f, 0xdb, 0xe2, 0x7f, 0x16, 0xb4, 0x60, 0x3e);
			
			public new VTable* VT { get => (.)vt; }
			
			public HRESULT QuerySubSystems(IEnumVdsObject** ppEnum) mut => VT.QuerySubSystems(ref this, ppEnum);
			public HRESULT Reenumerate() mut => VT.Reenumerate(ref this);
			public HRESULT Refresh() mut => VT.Refresh(ref this);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsHwProvider self, IEnumVdsObject** ppEnum) QuerySubSystems;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsHwProvider self) Reenumerate;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsHwProvider self) Refresh;
			}
		}
		[CRepr]
		public struct IVdsHwProviderType : IUnknown
		{
			public const new Guid IID = .(0x3e0f5166, 0x542d, 0x4fc6, 0x94, 0x7a, 0x01, 0x21, 0x74, 0x24, 0x0b, 0x7e);
			
			public new VTable* VT { get => (.)vt; }
			
			public HRESULT GetProviderType(out VDS_HWPROVIDER_TYPE pType) mut => VT.GetProviderType(ref this, out pType);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsHwProviderType self, out VDS_HWPROVIDER_TYPE pType) GetProviderType;
			}
		}
		[CRepr]
		public struct IVdsHwProviderType2 : IUnknown
		{
			public const new Guid IID = .(0x8190236f, 0xc4d0, 0x4e81, 0x80, 0x11, 0xd6, 0x95, 0x12, 0xfc, 0xc9, 0x84);
			
			public new VTable* VT { get => (.)vt; }
			
			public HRESULT GetProviderType2(out VDS_HWPROVIDER_TYPE pType) mut => VT.GetProviderType2(ref this, out pType);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsHwProviderType2 self, out VDS_HWPROVIDER_TYPE pType) GetProviderType2;
			}
		}
		[CRepr]
		public struct IVdsHwProviderStoragePools : IUnknown
		{
			public const new Guid IID = .(0xd5b5937a, 0xf188, 0x4c79, 0xb8, 0x6c, 0x11, 0xc9, 0x20, 0xad, 0x11, 0xb8);
			
			public new VTable* VT { get => (.)vt; }
			
			public HRESULT QueryStoragePools(uint32 ulFlags, uint64 ullRemainingFreeSpace, VDS_POOL_ATTRIBUTES* pPoolAttributes, IEnumVdsObject** ppEnum) mut => VT.QueryStoragePools(ref this, ulFlags, ullRemainingFreeSpace, pPoolAttributes, ppEnum);
			public HRESULT CreateLunInStoragePool(VDS_LUN_TYPE type, uint64 ullSizeInBytes, Guid StoragePoolId, PWSTR pwszUnmaskingList, VDS_HINTS2* pHints2, IVdsAsync** ppAsync) mut => VT.CreateLunInStoragePool(ref this, type, ullSizeInBytes, StoragePoolId, pwszUnmaskingList, pHints2, ppAsync);
			public HRESULT QueryMaxLunCreateSizeInStoragePool(VDS_LUN_TYPE type, Guid StoragePoolId, VDS_HINTS2* pHints2, out uint64 pullMaxLunSize) mut => VT.QueryMaxLunCreateSizeInStoragePool(ref this, type, StoragePoolId, pHints2, out pullMaxLunSize);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsHwProviderStoragePools self, uint32 ulFlags, uint64 ullRemainingFreeSpace, VDS_POOL_ATTRIBUTES* pPoolAttributes, IEnumVdsObject** ppEnum) QueryStoragePools;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsHwProviderStoragePools self, VDS_LUN_TYPE type, uint64 ullSizeInBytes, Guid StoragePoolId, PWSTR pwszUnmaskingList, VDS_HINTS2* pHints2, IVdsAsync** ppAsync) CreateLunInStoragePool;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsHwProviderStoragePools self, VDS_LUN_TYPE type, Guid StoragePoolId, VDS_HINTS2* pHints2, out uint64 pullMaxLunSize) QueryMaxLunCreateSizeInStoragePool;
			}
		}
		[CRepr]
		public struct IVdsSubSystem : IUnknown
		{
			public const new Guid IID = .(0x6fcee2d3, 0x6d90, 0x4f91, 0x80, 0xe2, 0xa5, 0xc7, 0xca, 0xac, 0xa9, 0xd8);
			
			public new VTable* VT { get => (.)vt; }
			
			public HRESULT GetProperties(out VDS_SUB_SYSTEM_PROP pSubSystemProp) mut => VT.GetProperties(ref this, out pSubSystemProp);
			public HRESULT GetProvider(IVdsProvider** ppProvider) mut => VT.GetProvider(ref this, ppProvider);
			public HRESULT QueryControllers(IEnumVdsObject** ppEnum) mut => VT.QueryControllers(ref this, ppEnum);
			public HRESULT QueryLuns(IEnumVdsObject** ppEnum) mut => VT.QueryLuns(ref this, ppEnum);
			public HRESULT QueryDrives(IEnumVdsObject** ppEnum) mut => VT.QueryDrives(ref this, ppEnum);
			public HRESULT GetDrive(int16 sBusNumber, int16 sSlotNumber, IVdsDrive** ppDrive) mut => VT.GetDrive(ref this, sBusNumber, sSlotNumber, ppDrive);
			public HRESULT Reenumerate() mut => VT.Reenumerate(ref this);
			public HRESULT SetControllerStatus(Guid* pOnlineControllerIdArray, int32 lNumberOfOnlineControllers, Guid* pOfflineControllerIdArray, int32 lNumberOfOfflineControllers) mut => VT.SetControllerStatus(ref this, pOnlineControllerIdArray, lNumberOfOnlineControllers, pOfflineControllerIdArray, lNumberOfOfflineControllers);
			public HRESULT CreateLun(VDS_LUN_TYPE type, uint64 ullSizeInBytes, Guid* pDriveIdArray, int32 lNumberOfDrives, PWSTR pwszUnmaskingList, VDS_HINTS* pHints, IVdsAsync** ppAsync) mut => VT.CreateLun(ref this, type, ullSizeInBytes, pDriveIdArray, lNumberOfDrives, pwszUnmaskingList, pHints, ppAsync);
			public HRESULT ReplaceDrive(Guid DriveToBeReplaced, Guid ReplacementDrive) mut => VT.ReplaceDrive(ref this, DriveToBeReplaced, ReplacementDrive);
			public HRESULT SetStatus(VDS_SUB_SYSTEM_STATUS status) mut => VT.SetStatus(ref this, status);
			public HRESULT QueryMaxLunCreateSize(VDS_LUN_TYPE type, Guid* pDriveIdArray, int32 lNumberOfDrives, VDS_HINTS* pHints, out uint64 pullMaxLunSize) mut => VT.QueryMaxLunCreateSize(ref this, type, pDriveIdArray, lNumberOfDrives, pHints, out pullMaxLunSize);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsSubSystem self, out VDS_SUB_SYSTEM_PROP pSubSystemProp) GetProperties;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsSubSystem self, IVdsProvider** ppProvider) GetProvider;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsSubSystem self, IEnumVdsObject** ppEnum) QueryControllers;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsSubSystem self, IEnumVdsObject** ppEnum) QueryLuns;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsSubSystem self, IEnumVdsObject** ppEnum) QueryDrives;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsSubSystem self, int16 sBusNumber, int16 sSlotNumber, IVdsDrive** ppDrive) GetDrive;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsSubSystem self) Reenumerate;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsSubSystem self, Guid* pOnlineControllerIdArray, int32 lNumberOfOnlineControllers, Guid* pOfflineControllerIdArray, int32 lNumberOfOfflineControllers) SetControllerStatus;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsSubSystem self, VDS_LUN_TYPE type, uint64 ullSizeInBytes, Guid* pDriveIdArray, int32 lNumberOfDrives, PWSTR pwszUnmaskingList, VDS_HINTS* pHints, IVdsAsync** ppAsync) CreateLun;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsSubSystem self, Guid DriveToBeReplaced, Guid ReplacementDrive) ReplaceDrive;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsSubSystem self, VDS_SUB_SYSTEM_STATUS status) SetStatus;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsSubSystem self, VDS_LUN_TYPE type, Guid* pDriveIdArray, int32 lNumberOfDrives, VDS_HINTS* pHints, out uint64 pullMaxLunSize) QueryMaxLunCreateSize;
			}
		}
		[CRepr]
		public struct IVdsSubSystem2 : IUnknown
		{
			public const new Guid IID = .(0xbe666735, 0x7800, 0x4a77, 0x9d, 0x9c, 0x40, 0xf8, 0x5b, 0x87, 0xe2, 0x92);
			
			public new VTable* VT { get => (.)vt; }
			
			public HRESULT GetProperties2(out VDS_SUB_SYSTEM_PROP2 pSubSystemProp2) mut => VT.GetProperties2(ref this, out pSubSystemProp2);
			public HRESULT GetDrive2(int16 sBusNumber, int16 sSlotNumber, uint32 ulEnclosureNumber, IVdsDrive** ppDrive) mut => VT.GetDrive2(ref this, sBusNumber, sSlotNumber, ulEnclosureNumber, ppDrive);
			public HRESULT CreateLun2(VDS_LUN_TYPE type, uint64 ullSizeInBytes, Guid* pDriveIdArray, int32 lNumberOfDrives, PWSTR pwszUnmaskingList, VDS_HINTS2* pHints2, IVdsAsync** ppAsync) mut => VT.CreateLun2(ref this, type, ullSizeInBytes, pDriveIdArray, lNumberOfDrives, pwszUnmaskingList, pHints2, ppAsync);
			public HRESULT QueryMaxLunCreateSize2(VDS_LUN_TYPE type, Guid* pDriveIdArray, int32 lNumberOfDrives, VDS_HINTS2* pHints2, out uint64 pullMaxLunSize) mut => VT.QueryMaxLunCreateSize2(ref this, type, pDriveIdArray, lNumberOfDrives, pHints2, out pullMaxLunSize);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsSubSystem2 self, out VDS_SUB_SYSTEM_PROP2 pSubSystemProp2) GetProperties2;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsSubSystem2 self, int16 sBusNumber, int16 sSlotNumber, uint32 ulEnclosureNumber, IVdsDrive** ppDrive) GetDrive2;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsSubSystem2 self, VDS_LUN_TYPE type, uint64 ullSizeInBytes, Guid* pDriveIdArray, int32 lNumberOfDrives, PWSTR pwszUnmaskingList, VDS_HINTS2* pHints2, IVdsAsync** ppAsync) CreateLun2;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsSubSystem2 self, VDS_LUN_TYPE type, Guid* pDriveIdArray, int32 lNumberOfDrives, VDS_HINTS2* pHints2, out uint64 pullMaxLunSize) QueryMaxLunCreateSize2;
			}
		}
		[CRepr]
		public struct IVdsSubSystemNaming : IUnknown
		{
			public const new Guid IID = .(0x0d70faa3, 0x9cd4, 0x4900, 0xaa, 0x20, 0x69, 0x81, 0xb6, 0xaa, 0xfc, 0x75);
			
			public new VTable* VT { get => (.)vt; }
			
			public HRESULT SetFriendlyName(PWSTR pwszFriendlyName) mut => VT.SetFriendlyName(ref this, pwszFriendlyName);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsSubSystemNaming self, PWSTR pwszFriendlyName) SetFriendlyName;
			}
		}
		[CRepr]
		public struct IVdsSubSystemIscsi : IUnknown
		{
			public const new Guid IID = .(0x0027346f, 0x40d0, 0x4b45, 0x8c, 0xec, 0x59, 0x06, 0xdc, 0x03, 0x80, 0xc8);
			
			public new VTable* VT { get => (.)vt; }
			
			public HRESULT QueryTargets(IEnumVdsObject** ppEnum) mut => VT.QueryTargets(ref this, ppEnum);
			public HRESULT QueryPortals(IEnumVdsObject** ppEnum) mut => VT.QueryPortals(ref this, ppEnum);
			public HRESULT CreateTarget(PWSTR pwszIscsiName, PWSTR pwszFriendlyName, IVdsAsync** ppAsync) mut => VT.CreateTarget(ref this, pwszIscsiName, pwszFriendlyName, ppAsync);
			public HRESULT SetIpsecGroupPresharedKey(VDS_ISCSI_IPSEC_KEY* pIpsecKey) mut => VT.SetIpsecGroupPresharedKey(ref this, pIpsecKey);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsSubSystemIscsi self, IEnumVdsObject** ppEnum) QueryTargets;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsSubSystemIscsi self, IEnumVdsObject** ppEnum) QueryPortals;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsSubSystemIscsi self, PWSTR pwszIscsiName, PWSTR pwszFriendlyName, IVdsAsync** ppAsync) CreateTarget;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsSubSystemIscsi self, VDS_ISCSI_IPSEC_KEY* pIpsecKey) SetIpsecGroupPresharedKey;
			}
		}
		[CRepr]
		public struct IVdsSubSystemInterconnect : IUnknown
		{
			public const new Guid IID = .(0x9e6fa560, 0xc141, 0x477b, 0x83, 0xba, 0x0b, 0x6c, 0x38, 0xf7, 0xfe, 0xbf);
			
			public new VTable* VT { get => (.)vt; }
			
			public HRESULT GetSupportedInterconnects(out uint32 pulSupportedInterconnectsFlag) mut => VT.GetSupportedInterconnects(ref this, out pulSupportedInterconnectsFlag);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsSubSystemInterconnect self, out uint32 pulSupportedInterconnectsFlag) GetSupportedInterconnects;
			}
		}
		[CRepr]
		public struct IVdsControllerPort : IUnknown
		{
			public const new Guid IID = .(0x18691d0d, 0x4e7f, 0x43e8, 0x92, 0xe4, 0xcf, 0x44, 0xbe, 0xee, 0xd1, 0x1c);
			
			public new VTable* VT { get => (.)vt; }
			
			public HRESULT GetProperties(out VDS_PORT_PROP pPortProp) mut => VT.GetProperties(ref this, out pPortProp);
			public HRESULT GetController(IVdsController** ppController) mut => VT.GetController(ref this, ppController);
			public HRESULT QueryAssociatedLuns(IEnumVdsObject** ppEnum) mut => VT.QueryAssociatedLuns(ref this, ppEnum);
			public HRESULT Reset() mut => VT.Reset(ref this);
			public HRESULT SetStatus(VDS_PORT_STATUS status) mut => VT.SetStatus(ref this, status);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsControllerPort self, out VDS_PORT_PROP pPortProp) GetProperties;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsControllerPort self, IVdsController** ppController) GetController;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsControllerPort self, IEnumVdsObject** ppEnum) QueryAssociatedLuns;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsControllerPort self) Reset;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsControllerPort self, VDS_PORT_STATUS status) SetStatus;
			}
		}
		[CRepr]
		public struct IVdsController : IUnknown
		{
			public const new Guid IID = .(0xcb53d96e, 0xdffb, 0x474a, 0xa0, 0x78, 0x79, 0x0d, 0x1e, 0x2b, 0xc0, 0x82);
			
			public new VTable* VT { get => (.)vt; }
			
			public HRESULT GetProperties(out VDS_CONTROLLER_PROP pControllerProp) mut => VT.GetProperties(ref this, out pControllerProp);
			public HRESULT GetSubSystem(IVdsSubSystem** ppSubSystem) mut => VT.GetSubSystem(ref this, ppSubSystem);
			public HRESULT GetPortProperties(int16 sPortNumber, out VDS_PORT_PROP pPortProp) mut => VT.GetPortProperties(ref this, sPortNumber, out pPortProp);
			public HRESULT FlushCache() mut => VT.FlushCache(ref this);
			public HRESULT InvalidateCache() mut => VT.InvalidateCache(ref this);
			public HRESULT Reset() mut => VT.Reset(ref this);
			public HRESULT QueryAssociatedLuns(IEnumVdsObject** ppEnum) mut => VT.QueryAssociatedLuns(ref this, ppEnum);
			public HRESULT SetStatus(VDS_CONTROLLER_STATUS status) mut => VT.SetStatus(ref this, status);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsController self, out VDS_CONTROLLER_PROP pControllerProp) GetProperties;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsController self, IVdsSubSystem** ppSubSystem) GetSubSystem;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsController self, int16 sPortNumber, out VDS_PORT_PROP pPortProp) GetPortProperties;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsController self) FlushCache;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsController self) InvalidateCache;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsController self) Reset;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsController self, IEnumVdsObject** ppEnum) QueryAssociatedLuns;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsController self, VDS_CONTROLLER_STATUS status) SetStatus;
			}
		}
		[CRepr]
		public struct IVdsControllerControllerPort : IUnknown
		{
			public const new Guid IID = .(0xca5d735f, 0x6bae, 0x42c0, 0xb3, 0x0e, 0xf2, 0x66, 0x60, 0x45, 0xce, 0x71);
			
			public new VTable* VT { get => (.)vt; }
			
			public HRESULT QueryControllerPorts(IEnumVdsObject** ppEnum) mut => VT.QueryControllerPorts(ref this, ppEnum);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsControllerControllerPort self, IEnumVdsObject** ppEnum) QueryControllerPorts;
			}
		}
		[CRepr]
		public struct IVdsDrive : IUnknown
		{
			public const new Guid IID = .(0xff24efa4, 0xaade, 0x4b6b, 0x89, 0x8b, 0xea, 0xa6, 0xa2, 0x08, 0x87, 0xc7);
			
			public new VTable* VT { get => (.)vt; }
			
			public HRESULT GetProperties(out VDS_DRIVE_PROP pDriveProp) mut => VT.GetProperties(ref this, out pDriveProp);
			public HRESULT GetSubSystem(IVdsSubSystem** ppSubSystem) mut => VT.GetSubSystem(ref this, ppSubSystem);
			public HRESULT QueryExtents(VDS_DRIVE_EXTENT** ppExtentArray, out int32 plNumberOfExtents) mut => VT.QueryExtents(ref this, ppExtentArray, out plNumberOfExtents);
			public HRESULT SetFlags(uint32 ulFlags) mut => VT.SetFlags(ref this, ulFlags);
			public HRESULT ClearFlags(uint32 ulFlags) mut => VT.ClearFlags(ref this, ulFlags);
			public HRESULT SetStatus(VDS_DRIVE_STATUS status) mut => VT.SetStatus(ref this, status);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsDrive self, out VDS_DRIVE_PROP pDriveProp) GetProperties;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsDrive self, IVdsSubSystem** ppSubSystem) GetSubSystem;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsDrive self, VDS_DRIVE_EXTENT** ppExtentArray, out int32 plNumberOfExtents) QueryExtents;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsDrive self, uint32 ulFlags) SetFlags;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsDrive self, uint32 ulFlags) ClearFlags;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsDrive self, VDS_DRIVE_STATUS status) SetStatus;
			}
		}
		[CRepr]
		public struct IVdsDrive2 : IUnknown
		{
			public const new Guid IID = .(0x60b5a730, 0xaddf, 0x4436, 0x8c, 0xa7, 0x57, 0x69, 0xe2, 0xd1, 0xff, 0xa4);
			
			public new VTable* VT { get => (.)vt; }
			
			public HRESULT GetProperties2(out VDS_DRIVE_PROP2 pDriveProp2) mut => VT.GetProperties2(ref this, out pDriveProp2);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsDrive2 self, out VDS_DRIVE_PROP2 pDriveProp2) GetProperties2;
			}
		}
		[CRepr]
		public struct IVdsLun : IUnknown
		{
			public const new Guid IID = .(0x3540a9c7, 0xe60f, 0x4111, 0xa8, 0x40, 0x8b, 0xba, 0x6c, 0x2c, 0x83, 0xd8);
			
			public new VTable* VT { get => (.)vt; }
			
			public HRESULT GetProperties(out VDS_LUN_PROP pLunProp) mut => VT.GetProperties(ref this, out pLunProp);
			public HRESULT GetSubSystem(IVdsSubSystem** ppSubSystem) mut => VT.GetSubSystem(ref this, ppSubSystem);
			public HRESULT GetIdentificationData(out VDS_LUN_INFORMATION pLunInfo) mut => VT.GetIdentificationData(ref this, out pLunInfo);
			public HRESULT QueryActiveControllers(IEnumVdsObject** ppEnum) mut => VT.QueryActiveControllers(ref this, ppEnum);
			public HRESULT Extend(uint64 ullNumberOfBytesToAdd, Guid* pDriveIdArray, int32 lNumberOfDrives, IVdsAsync** ppAsync) mut => VT.Extend(ref this, ullNumberOfBytesToAdd, pDriveIdArray, lNumberOfDrives, ppAsync);
			public HRESULT Shrink(uint64 ullNumberOfBytesToRemove, IVdsAsync** ppAsync) mut => VT.Shrink(ref this, ullNumberOfBytesToRemove, ppAsync);
			public HRESULT QueryPlexes(IEnumVdsObject** ppEnum) mut => VT.QueryPlexes(ref this, ppEnum);
			public HRESULT AddPlex(Guid lunId, IVdsAsync** ppAsync) mut => VT.AddPlex(ref this, lunId, ppAsync);
			public HRESULT RemovePlex(Guid plexId, IVdsAsync** ppAsync) mut => VT.RemovePlex(ref this, plexId, ppAsync);
			public HRESULT Recover(IVdsAsync** ppAsync) mut => VT.Recover(ref this, ppAsync);
			public HRESULT SetMask(PWSTR pwszUnmaskingList) mut => VT.SetMask(ref this, pwszUnmaskingList);
			public HRESULT Delete() mut => VT.Delete(ref this);
			public HRESULT AssociateControllers(Guid* pActiveControllerIdArray, int32 lNumberOfActiveControllers, Guid* pInactiveControllerIdArray, int32 lNumberOfInactiveControllers) mut => VT.AssociateControllers(ref this, pActiveControllerIdArray, lNumberOfActiveControllers, pInactiveControllerIdArray, lNumberOfInactiveControllers);
			public HRESULT QueryHints(out VDS_HINTS pHints) mut => VT.QueryHints(ref this, out pHints);
			public HRESULT ApplyHints(ref VDS_HINTS pHints) mut => VT.ApplyHints(ref this, ref pHints);
			public HRESULT SetStatus(VDS_LUN_STATUS status) mut => VT.SetStatus(ref this, status);
			public HRESULT QueryMaxLunExtendSize(Guid* pDriveIdArray, int32 lNumberOfDrives, out uint64 pullMaxBytesToBeAdded) mut => VT.QueryMaxLunExtendSize(ref this, pDriveIdArray, lNumberOfDrives, out pullMaxBytesToBeAdded);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsLun self, out VDS_LUN_PROP pLunProp) GetProperties;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsLun self, IVdsSubSystem** ppSubSystem) GetSubSystem;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsLun self, out VDS_LUN_INFORMATION pLunInfo) GetIdentificationData;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsLun self, IEnumVdsObject** ppEnum) QueryActiveControllers;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsLun self, uint64 ullNumberOfBytesToAdd, Guid* pDriveIdArray, int32 lNumberOfDrives, IVdsAsync** ppAsync) Extend;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsLun self, uint64 ullNumberOfBytesToRemove, IVdsAsync** ppAsync) Shrink;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsLun self, IEnumVdsObject** ppEnum) QueryPlexes;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsLun self, Guid lunId, IVdsAsync** ppAsync) AddPlex;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsLun self, Guid plexId, IVdsAsync** ppAsync) RemovePlex;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsLun self, IVdsAsync** ppAsync) Recover;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsLun self, PWSTR pwszUnmaskingList) SetMask;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsLun self) Delete;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsLun self, Guid* pActiveControllerIdArray, int32 lNumberOfActiveControllers, Guid* pInactiveControllerIdArray, int32 lNumberOfInactiveControllers) AssociateControllers;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsLun self, out VDS_HINTS pHints) QueryHints;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsLun self, ref VDS_HINTS pHints) ApplyHints;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsLun self, VDS_LUN_STATUS status) SetStatus;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsLun self, Guid* pDriveIdArray, int32 lNumberOfDrives, out uint64 pullMaxBytesToBeAdded) QueryMaxLunExtendSize;
			}
		}
		[CRepr]
		public struct IVdsLun2 : IUnknown
		{
			public const new Guid IID = .(0xe5b3a735, 0x9efb, 0x499a, 0x80, 0x71, 0x43, 0x94, 0xd9, 0xee, 0x6f, 0xcb);
			
			public new VTable* VT { get => (.)vt; }
			
			public HRESULT QueryHints2(out VDS_HINTS2 pHints2) mut => VT.QueryHints2(ref this, out pHints2);
			public HRESULT ApplyHints2(ref VDS_HINTS2 pHints2) mut => VT.ApplyHints2(ref this, ref pHints2);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsLun2 self, out VDS_HINTS2 pHints2) QueryHints2;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsLun2 self, ref VDS_HINTS2 pHints2) ApplyHints2;
			}
		}
		[CRepr]
		public struct IVdsLunNaming : IUnknown
		{
			public const new Guid IID = .(0x907504cb, 0x6b4e, 0x4d88, 0xa3, 0x4d, 0x17, 0xba, 0x66, 0x1f, 0xbb, 0x06);
			
			public new VTable* VT { get => (.)vt; }
			
			public HRESULT SetFriendlyName(PWSTR pwszFriendlyName) mut => VT.SetFriendlyName(ref this, pwszFriendlyName);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsLunNaming self, PWSTR pwszFriendlyName) SetFriendlyName;
			}
		}
		[CRepr]
		public struct IVdsLunNumber : IUnknown
		{
			public const new Guid IID = .(0xd3f95e46, 0x54b3, 0x41f9, 0xb6, 0x78, 0x0f, 0x18, 0x71, 0x44, 0x3a, 0x08);
			
			public new VTable* VT { get => (.)vt; }
			
			public HRESULT GetLunNumber(out uint32 pulLunNumber) mut => VT.GetLunNumber(ref this, out pulLunNumber);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsLunNumber self, out uint32 pulLunNumber) GetLunNumber;
			}
		}
		[CRepr]
		public struct IVdsLunControllerPorts : IUnknown
		{
			public const new Guid IID = .(0x451fe266, 0xda6d, 0x406a, 0xbb, 0x60, 0x82, 0xe5, 0x34, 0xf8, 0x5a, 0xeb);
			
			public new VTable* VT { get => (.)vt; }
			
			public HRESULT AssociateControllerPorts(Guid* pActiveControllerPortIdArray, int32 lNumberOfActiveControllerPorts, Guid* pInactiveControllerPortIdArray, int32 lNumberOfInactiveControllerPorts) mut => VT.AssociateControllerPorts(ref this, pActiveControllerPortIdArray, lNumberOfActiveControllerPorts, pInactiveControllerPortIdArray, lNumberOfInactiveControllerPorts);
			public HRESULT QueryActiveControllerPorts(IEnumVdsObject** ppEnum) mut => VT.QueryActiveControllerPorts(ref this, ppEnum);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsLunControllerPorts self, Guid* pActiveControllerPortIdArray, int32 lNumberOfActiveControllerPorts, Guid* pInactiveControllerPortIdArray, int32 lNumberOfInactiveControllerPorts) AssociateControllerPorts;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsLunControllerPorts self, IEnumVdsObject** ppEnum) QueryActiveControllerPorts;
			}
		}
		[CRepr]
		public struct IVdsLunMpio : IUnknown
		{
			public const new Guid IID = .(0x7c5fbae3, 0x333a, 0x48a1, 0xa9, 0x82, 0x33, 0xc1, 0x57, 0x88, 0xcd, 0xe3);
			
			public new VTable* VT { get => (.)vt; }
			
			public HRESULT GetPathInfo(VDS_PATH_INFO** ppPaths, out int32 plNumberOfPaths) mut => VT.GetPathInfo(ref this, ppPaths, out plNumberOfPaths);
			public HRESULT GetLoadBalancePolicy(out VDS_LOADBALANCE_POLICY_ENUM pPolicy, VDS_PATH_POLICY** ppPaths, out int32 plNumberOfPaths) mut => VT.GetLoadBalancePolicy(ref this, out pPolicy, ppPaths, out plNumberOfPaths);
			public HRESULT SetLoadBalancePolicy(VDS_LOADBALANCE_POLICY_ENUM policy, VDS_PATH_POLICY* pPaths, int32 lNumberOfPaths) mut => VT.SetLoadBalancePolicy(ref this, policy, pPaths, lNumberOfPaths);
			public HRESULT GetSupportedLbPolicies(out uint32 pulLbFlags) mut => VT.GetSupportedLbPolicies(ref this, out pulLbFlags);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsLunMpio self, VDS_PATH_INFO** ppPaths, out int32 plNumberOfPaths) GetPathInfo;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsLunMpio self, out VDS_LOADBALANCE_POLICY_ENUM pPolicy, VDS_PATH_POLICY** ppPaths, out int32 plNumberOfPaths) GetLoadBalancePolicy;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsLunMpio self, VDS_LOADBALANCE_POLICY_ENUM policy, VDS_PATH_POLICY* pPaths, int32 lNumberOfPaths) SetLoadBalancePolicy;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsLunMpio self, out uint32 pulLbFlags) GetSupportedLbPolicies;
			}
		}
		[CRepr]
		public struct IVdsLunIscsi : IUnknown
		{
			public const new Guid IID = .(0x0d7c1e64, 0xb59b, 0x45ae, 0xb8, 0x6a, 0x2c, 0x2c, 0xc6, 0xa4, 0x20, 0x67);
			
			public new VTable* VT { get => (.)vt; }
			
			public HRESULT AssociateTargets(Guid* pTargetIdArray, int32 lNumberOfTargets) mut => VT.AssociateTargets(ref this, pTargetIdArray, lNumberOfTargets);
			public HRESULT QueryAssociatedTargets(IEnumVdsObject** ppEnum) mut => VT.QueryAssociatedTargets(ref this, ppEnum);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsLunIscsi self, Guid* pTargetIdArray, int32 lNumberOfTargets) AssociateTargets;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsLunIscsi self, IEnumVdsObject** ppEnum) QueryAssociatedTargets;
			}
		}
		[CRepr]
		public struct IVdsLunPlex : IUnknown
		{
			public const new Guid IID = .(0x0ee1a790, 0x5d2e, 0x4abb, 0x8c, 0x99, 0xc4, 0x81, 0xe8, 0xbe, 0x21, 0x38);
			
			public new VTable* VT { get => (.)vt; }
			
			public HRESULT GetProperties(out VDS_LUN_PLEX_PROP pPlexProp) mut => VT.GetProperties(ref this, out pPlexProp);
			public HRESULT GetLun(IVdsLun** ppLun) mut => VT.GetLun(ref this, ppLun);
			public HRESULT QueryExtents(VDS_DRIVE_EXTENT** ppExtentArray, out int32 plNumberOfExtents) mut => VT.QueryExtents(ref this, ppExtentArray, out plNumberOfExtents);
			public HRESULT QueryHints(out VDS_HINTS pHints) mut => VT.QueryHints(ref this, out pHints);
			public HRESULT ApplyHints(ref VDS_HINTS pHints) mut => VT.ApplyHints(ref this, ref pHints);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsLunPlex self, out VDS_LUN_PLEX_PROP pPlexProp) GetProperties;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsLunPlex self, IVdsLun** ppLun) GetLun;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsLunPlex self, VDS_DRIVE_EXTENT** ppExtentArray, out int32 plNumberOfExtents) QueryExtents;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsLunPlex self, out VDS_HINTS pHints) QueryHints;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsLunPlex self, ref VDS_HINTS pHints) ApplyHints;
			}
		}
		[CRepr]
		public struct IVdsIscsiPortal : IUnknown
		{
			public const new Guid IID = .(0x7fa1499d, 0xec85, 0x4a8a, 0xa4, 0x7b, 0xff, 0x69, 0x20, 0x1f, 0xcd, 0x34);
			
			public new VTable* VT { get => (.)vt; }
			
			public HRESULT GetProperties(out VDS_ISCSI_PORTAL_PROP pPortalProp) mut => VT.GetProperties(ref this, out pPortalProp);
			public HRESULT GetSubSystem(IVdsSubSystem** ppSubSystem) mut => VT.GetSubSystem(ref this, ppSubSystem);
			public HRESULT QueryAssociatedPortalGroups(IEnumVdsObject** ppEnum) mut => VT.QueryAssociatedPortalGroups(ref this, ppEnum);
			public HRESULT SetStatus(VDS_ISCSI_PORTAL_STATUS status) mut => VT.SetStatus(ref this, status);
			public HRESULT SetIpsecTunnelAddress(ref VDS_IPADDRESS pTunnelAddress, ref VDS_IPADDRESS pDestinationAddress) mut => VT.SetIpsecTunnelAddress(ref this, ref pTunnelAddress, ref pDestinationAddress);
			public HRESULT GetIpsecSecurity(ref VDS_IPADDRESS pInitiatorPortalAddress, out uint64 pullSecurityFlags) mut => VT.GetIpsecSecurity(ref this, ref pInitiatorPortalAddress, out pullSecurityFlags);
			public HRESULT SetIpsecSecurity(ref VDS_IPADDRESS pInitiatorPortalAddress, uint64 ullSecurityFlags, VDS_ISCSI_IPSEC_KEY* pIpsecKey) mut => VT.SetIpsecSecurity(ref this, ref pInitiatorPortalAddress, ullSecurityFlags, pIpsecKey);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsIscsiPortal self, out VDS_ISCSI_PORTAL_PROP pPortalProp) GetProperties;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsIscsiPortal self, IVdsSubSystem** ppSubSystem) GetSubSystem;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsIscsiPortal self, IEnumVdsObject** ppEnum) QueryAssociatedPortalGroups;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsIscsiPortal self, VDS_ISCSI_PORTAL_STATUS status) SetStatus;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsIscsiPortal self, ref VDS_IPADDRESS pTunnelAddress, ref VDS_IPADDRESS pDestinationAddress) SetIpsecTunnelAddress;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsIscsiPortal self, ref VDS_IPADDRESS pInitiatorPortalAddress, out uint64 pullSecurityFlags) GetIpsecSecurity;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsIscsiPortal self, ref VDS_IPADDRESS pInitiatorPortalAddress, uint64 ullSecurityFlags, VDS_ISCSI_IPSEC_KEY* pIpsecKey) SetIpsecSecurity;
			}
		}
		[CRepr]
		public struct IVdsIscsiTarget : IUnknown
		{
			public const new Guid IID = .(0xaa8f5055, 0x83e5, 0x4bcc, 0xaa, 0x73, 0x19, 0x85, 0x1a, 0x36, 0xa8, 0x49);
			
			public new VTable* VT { get => (.)vt; }
			
			public HRESULT GetProperties(out VDS_ISCSI_TARGET_PROP pTargetProp) mut => VT.GetProperties(ref this, out pTargetProp);
			public HRESULT GetSubSystem(IVdsSubSystem** ppSubSystem) mut => VT.GetSubSystem(ref this, ppSubSystem);
			public HRESULT QueryPortalGroups(IEnumVdsObject** ppEnum) mut => VT.QueryPortalGroups(ref this, ppEnum);
			public HRESULT QueryAssociatedLuns(IEnumVdsObject** ppEnum) mut => VT.QueryAssociatedLuns(ref this, ppEnum);
			public HRESULT CreatePortalGroup(IVdsAsync** ppAsync) mut => VT.CreatePortalGroup(ref this, ppAsync);
			public HRESULT Delete(IVdsAsync** ppAsync) mut => VT.Delete(ref this, ppAsync);
			public HRESULT SetFriendlyName(PWSTR pwszFriendlyName) mut => VT.SetFriendlyName(ref this, pwszFriendlyName);
			public HRESULT SetSharedSecret(VDS_ISCSI_SHARED_SECRET* pTargetSharedSecret, PWSTR pwszInitiatorName) mut => VT.SetSharedSecret(ref this, pTargetSharedSecret, pwszInitiatorName);
			public HRESULT RememberInitiatorSharedSecret(PWSTR pwszInitiatorName, VDS_ISCSI_SHARED_SECRET* pInitiatorSharedSecret) mut => VT.RememberInitiatorSharedSecret(ref this, pwszInitiatorName, pInitiatorSharedSecret);
			public HRESULT GetConnectedInitiators(PWSTR** pppwszInitiatorList, out int32 plNumberOfInitiators) mut => VT.GetConnectedInitiators(ref this, pppwszInitiatorList, out plNumberOfInitiators);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsIscsiTarget self, out VDS_ISCSI_TARGET_PROP pTargetProp) GetProperties;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsIscsiTarget self, IVdsSubSystem** ppSubSystem) GetSubSystem;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsIscsiTarget self, IEnumVdsObject** ppEnum) QueryPortalGroups;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsIscsiTarget self, IEnumVdsObject** ppEnum) QueryAssociatedLuns;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsIscsiTarget self, IVdsAsync** ppAsync) CreatePortalGroup;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsIscsiTarget self, IVdsAsync** ppAsync) Delete;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsIscsiTarget self, PWSTR pwszFriendlyName) SetFriendlyName;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsIscsiTarget self, VDS_ISCSI_SHARED_SECRET* pTargetSharedSecret, PWSTR pwszInitiatorName) SetSharedSecret;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsIscsiTarget self, PWSTR pwszInitiatorName, VDS_ISCSI_SHARED_SECRET* pInitiatorSharedSecret) RememberInitiatorSharedSecret;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsIscsiTarget self, PWSTR** pppwszInitiatorList, out int32 plNumberOfInitiators) GetConnectedInitiators;
			}
		}
		[CRepr]
		public struct IVdsIscsiPortalGroup : IUnknown
		{
			public const new Guid IID = .(0xfef5f89d, 0xa3dd, 0x4b36, 0xbf, 0x28, 0xe7, 0xdd, 0xe0, 0x45, 0xc5, 0x93);
			
			public new VTable* VT { get => (.)vt; }
			
			public HRESULT GetProperties(out VDS_ISCSI_PORTALGROUP_PROP pPortalGroupProp) mut => VT.GetProperties(ref this, out pPortalGroupProp);
			public HRESULT GetTarget(IVdsIscsiTarget** ppTarget) mut => VT.GetTarget(ref this, ppTarget);
			public HRESULT QueryAssociatedPortals(IEnumVdsObject** ppEnum) mut => VT.QueryAssociatedPortals(ref this, ppEnum);
			public HRESULT AddPortal(Guid portalId, IVdsAsync** ppAsync) mut => VT.AddPortal(ref this, portalId, ppAsync);
			public HRESULT RemovePortal(Guid portalId, IVdsAsync** ppAsync) mut => VT.RemovePortal(ref this, portalId, ppAsync);
			public HRESULT Delete(IVdsAsync** ppAsync) mut => VT.Delete(ref this, ppAsync);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsIscsiPortalGroup self, out VDS_ISCSI_PORTALGROUP_PROP pPortalGroupProp) GetProperties;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsIscsiPortalGroup self, IVdsIscsiTarget** ppTarget) GetTarget;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsIscsiPortalGroup self, IEnumVdsObject** ppEnum) QueryAssociatedPortals;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsIscsiPortalGroup self, Guid portalId, IVdsAsync** ppAsync) AddPortal;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsIscsiPortalGroup self, Guid portalId, IVdsAsync** ppAsync) RemovePortal;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsIscsiPortalGroup self, IVdsAsync** ppAsync) Delete;
			}
		}
		[CRepr]
		public struct IVdsStoragePool : IUnknown
		{
			public const new Guid IID = .(0x932ca8cf, 0x0eb3, 0x4ba8, 0x96, 0x20, 0x22, 0x66, 0x5d, 0x7f, 0x84, 0x50);
			
			public new VTable* VT { get => (.)vt; }
			
			public HRESULT GetProvider(IVdsProvider** ppProvider) mut => VT.GetProvider(ref this, ppProvider);
			public HRESULT GetProperties(out VDS_STORAGE_POOL_PROP pStoragePoolProp) mut => VT.GetProperties(ref this, out pStoragePoolProp);
			public HRESULT GetAttributes(out VDS_POOL_ATTRIBUTES pStoragePoolAttributes) mut => VT.GetAttributes(ref this, out pStoragePoolAttributes);
			public HRESULT QueryDriveExtents(VDS_STORAGE_POOL_DRIVE_EXTENT** ppExtentArray, out int32 plNumberOfExtents) mut => VT.QueryDriveExtents(ref this, ppExtentArray, out plNumberOfExtents);
			public HRESULT QueryAllocatedLuns(IEnumVdsObject** ppEnum) mut => VT.QueryAllocatedLuns(ref this, ppEnum);
			public HRESULT QueryAllocatedStoragePools(IEnumVdsObject** ppEnum) mut => VT.QueryAllocatedStoragePools(ref this, ppEnum);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsStoragePool self, IVdsProvider** ppProvider) GetProvider;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsStoragePool self, out VDS_STORAGE_POOL_PROP pStoragePoolProp) GetProperties;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsStoragePool self, out VDS_POOL_ATTRIBUTES pStoragePoolAttributes) GetAttributes;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsStoragePool self, VDS_STORAGE_POOL_DRIVE_EXTENT** ppExtentArray, out int32 plNumberOfExtents) QueryDriveExtents;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsStoragePool self, IEnumVdsObject** ppEnum) QueryAllocatedLuns;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsStoragePool self, IEnumVdsObject** ppEnum) QueryAllocatedStoragePools;
			}
		}
		[CRepr]
		public struct IVdsMaintenance : IUnknown
		{
			public const new Guid IID = .(0xdaebeef3, 0x8523, 0x47ed, 0xa2, 0xb9, 0x05, 0xce, 0xcc, 0xe2, 0xa1, 0xae);
			
			public new VTable* VT { get => (.)vt; }
			
			public HRESULT StartMaintenance(VDS_MAINTENANCE_OPERATION operation) mut => VT.StartMaintenance(ref this, operation);
			public HRESULT StopMaintenance(VDS_MAINTENANCE_OPERATION operation) mut => VT.StopMaintenance(ref this, operation);
			public HRESULT PulseMaintenance(VDS_MAINTENANCE_OPERATION operation, uint32 ulCount) mut => VT.PulseMaintenance(ref this, operation, ulCount);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsMaintenance self, VDS_MAINTENANCE_OPERATION operation) StartMaintenance;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsMaintenance self, VDS_MAINTENANCE_OPERATION operation) StopMaintenance;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsMaintenance self, VDS_MAINTENANCE_OPERATION operation, uint32 ulCount) PulseMaintenance;
			}
		}
		[CRepr]
		public struct IVdsHwProviderPrivate : IUnknown
		{
			public const new Guid IID = .(0x98f17bf3, 0x9f33, 0x4f12, 0x87, 0x14, 0x8b, 0x40, 0x75, 0x09, 0x2c, 0x2e);
			
			public new VTable* VT { get => (.)vt; }
			
			public HRESULT QueryIfCreatedLun(PWSTR pwszDevicePath, ref VDS_LUN_INFORMATION pVdsLunInformation, out Guid pLunId) mut => VT.QueryIfCreatedLun(ref this, pwszDevicePath, ref pVdsLunInformation, out pLunId);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsHwProviderPrivate self, PWSTR pwszDevicePath, ref VDS_LUN_INFORMATION pVdsLunInformation, out Guid pLunId) QueryIfCreatedLun;
			}
		}
		[CRepr]
		public struct IVdsHwProviderPrivateMpio : IUnknown
		{
			public const new Guid IID = .(0x310a7715, 0xac2b, 0x4c6f, 0x98, 0x27, 0x3d, 0x74, 0x2f, 0x35, 0x16, 0x76);
			
			public new VTable* VT { get => (.)vt; }
			
			public HRESULT SetAllPathStatusesFromHbaPort(VDS_HBAPORT_PROP hbaPortProp, VDS_PATH_STATUS status) mut => VT.SetAllPathStatusesFromHbaPort(ref this, hbaPortProp, status);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsHwProviderPrivateMpio self, VDS_HBAPORT_PROP hbaPortProp, VDS_PATH_STATUS status) SetAllPathStatusesFromHbaPort;
			}
		}
		[CRepr]
		public struct IVdsAdmin : IUnknown
		{
			public const new Guid IID = .(0xd188e97d, 0x85aa, 0x4d33, 0xab, 0xc6, 0x26, 0x29, 0x9a, 0x10, 0xff, 0xc1);
			
			public new VTable* VT { get => (.)vt; }
			
			public HRESULT RegisterProvider(Guid providerId, Guid providerClsid, PWSTR pwszName, VDS_PROVIDER_TYPE type, PWSTR pwszMachineName, PWSTR pwszVersion, Guid guidVersionId) mut => VT.RegisterProvider(ref this, providerId, providerClsid, pwszName, type, pwszMachineName, pwszVersion, guidVersionId);
			public HRESULT UnregisterProvider(Guid providerId) mut => VT.UnregisterProvider(ref this, providerId);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsAdmin self, Guid providerId, Guid providerClsid, PWSTR pwszName, VDS_PROVIDER_TYPE type, PWSTR pwszMachineName, PWSTR pwszVersion, Guid guidVersionId) RegisterProvider;
				public new function [CallingConvention(.Stdcall)] HRESULT(ref IVdsAdmin self, Guid providerId) UnregisterProvider;
			}
		}
		
	}
}
